;; Analyzed by ClojureScript 0.0-3620
{:use-macros nil, :excludes #{}, :name cljs.core, :imports {StringBuffer goog.string.StringBuffer}, :requires {gstring goog.string, goog.string goog.string, gobject goog.object, goog.object goog.object, garray goog.array, goog.array goog.array, StringBuffer goog.string.StringBuffer}, :uses nil, :defs {->PersistentHashSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7811, :column 10, :end-line 7811, :end-column 27, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta hash-map __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta hash-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 7811, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9161, :column 7, :end-line 9161, :end-column 14, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & opts]), :arglists-meta (nil nil)}}, :name cljs.core/js->clj, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & opts]), :arglists-meta (nil nil)}, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9161, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & opts]), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords."}, sort-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2113, :column 7, :end-line 2113, :end-column 14, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([keyfn coll] [keyfn comp coll]), :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort-by, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([keyfn coll] [keyfn comp coll]), :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}, :method-params ([keyfn coll] [keyfn comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2113, :max-fixed-arity 3, :fn-var true, :arglists ([keyfn coll] [keyfn comp coll]), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ITransientAssociative {:meta {:file "cljs/core.cljs", :line 655, :column 14, :end-line 655, :end-column 35, :doc "Protocol for adding associativity to transient collections.", :protocol-symbol true, :protocol-info {:methods {-assoc! [[tcoll key val]]}}}, :protocol-symbol true, :name cljs.core/ITransientAssociative, :file "cljs/core.cljs", :end-column 35, :column nil, :line nil, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 655, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding associativity to transient collections."}, chunk-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3171, :column 7, :end-line 3171, :end-column 18, :arglists (quote ([s]))}, :name cljs.core/chunk-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3171, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, print-meta? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8626, :column 16, :end-line 8626, :end-column 27, :tag boolean, :arglists (quote ([opts obj]))}, :name cljs.core/print-meta?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([opts obj]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 8626, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([opts obj]))}, m3-hash-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 791, :column 15, :end-line 791, :end-column 26, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-int, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 791, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3575, :column 7, :end-line 3575, :end-column 14, :arglists (quote ([xform iter]))}, :name cljs.core/stepper, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3575, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter]))}, pr-str* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 739, :column 7, :end-line 739, :end-column 14, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, :name cljs.core/pr-str*, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 739, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9104, :column 7, :end-line 9104, :end-column 15, :arglists (quote ([xform* coll])), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}}, :name cljs.core/eduction, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}, :method-params [(xforms)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 9104, :max-fixed-arity 0, :fn-var true, :arglists ([& xforms]), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called."}, tree-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4429, :column 7, :end-line 4429, :end-column 15, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree."}, :name cljs.core/tree-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([branch? children root]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4429, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree."}, unchecked-remainder-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2411, :column 7, :end-line 2411, :end-column 30, :arglists (quote ([x n]))}, :name cljs.core/unchecked-remainder-int, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2411, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n]))}, uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9681, :column 7, :end-line 9681, :end-column 11, :arglists (quote ([s]))}, :name cljs.core/uuid, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9681, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1046, :column 12, :end-line 1046, :end-column 15, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, :name cljs.core/seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag seq, :end-line 1046, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 4031, :record false, :end-line 4031, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2147, :column 7, :end-line 2147, :end-column 13, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :name cljs.core/reduce, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2147, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll]), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called."}, INIT {:name cljs.core/INIT, :file "cljs/core.cljs", :line nil, :column nil, :end-line 3524, :end-column 10, :meta {:file "cljs/core.cljs", :line 3524, :column 6, :end-line 3524, :end-column 10}}, find-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9978, :column 7, :end-line 9978, :end-column 14, :arglists (quote ([ns]))}, :name cljs.core/find-ns, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9978, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns]))}, contains? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2004, :column 16, :end-line 2004, :end-column 25, :tag boolean, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, :name cljs.core/contains?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2004, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3726, :column 16, :end-line 3726, :end-column 22, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, :name cljs.core/every?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 3726, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, ->ES6IteratorSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1137, :column 10, :end-line 1137, :end-column 24, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :factory :positional, :arglists (quote ([value iter _rest]))}, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([value iter _rest]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 1137, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, Var {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :name cljs.core/Var, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 959, :record false, :end-line 959, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}}, keep-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4053, :column 7, :end-line 4053, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep-indexed, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4053, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided."}, ->PersistentQueueSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5329, :column 10, :end-line 5329, :end-column 28, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta front rear __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5329, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, subs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2607, :column 7, :end-line 2607, :end-column 11, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s start] [s start end]), :arglists ([s start] [s start end]), :arglists-meta (nil nil)}}, :name cljs.core/subs, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s start] [s start end]), :arglists ([s start] [s start end]), :arglists-meta (nil nil)}, :method-params ([s start] [s start end]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2607, :max-fixed-arity 3, :fn-var true, :arglists ([s start] [s start end]), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive."}, set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8042, :column 7, :end-line 8042, :end-column 10, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, :name cljs.core/set, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8042, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, compare-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2067, :column 17, :end-line 2067, :end-column 32, :private true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xs ys] [xs ys len n]), :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/compare-indexed, :variadic false, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xs ys] [xs ys len n]), :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}, :method-params ([xs ys] [xs ys len n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2067, :max-fixed-arity 4, :fn-var true, :arglists ([xs ys] [xs ys len n]), :doc "Compare indexed collection."}, take-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4267, :column 7, :end-line 4267, :end-column 16, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, :name cljs.core/take-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4267, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, IndexedSeq {:meta {:file "cljs/core.cljs", :line 1029, :column 29, :end-line 1029, :end-column 39, :declared true}, :num-fields 2, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 1361, :record false, :declared true, :end-line 1361, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}}, bit-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2522, :column 7, :end-line 2522, :end-column 14, :arglists (quote ([x n])), :doc "Set bit at index n"}, :name cljs.core/bit-set, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2522, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n"}, string-hash-cache-count {:name cljs.core/string-hash-cache-count, :file "cljs/core.cljs", :line nil, :column nil, :end-line 818, :end-column 29, :meta {:file "cljs/core.cljs", :line 818, :column 6, :end-line 818, :end-column 29}}, ->Eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9088, :column 10, :end-line 9088, :end-column 18, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :factory :positional, :arglists (quote ([xform coll]))}, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 9088, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, tree-map-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7326, :column 8, :end-line 7326, :end-column 20, :private true, :arglists (quote ([comp tree k v found]))}, :private true, :name cljs.core/tree-map-add, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([comp tree k v found]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7326, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found]))}, ->ES6SetEntriesIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5620, :column 10, :end-line 5620, :end-column 31, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5620, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, -with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 548, :column 9, :end-line 548, :end-column 19, :tag clj, :protocol cljs.core/IWithMeta, :doc "Returns a new object with value of o and metadata meta added to it.", :arglists (quote ([o meta]))}, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 548, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta])), :doc "Returns a new object with value of o and metadata meta added to it."}, reset-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9365, :column 8, :end-line 9365, :end-column 19, :private true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, :private true, :name cljs.core/reset-cache, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9365, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, ->PersistentArrayMapIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5772, :column 10, :end-line 5772, :end-column 36, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i cnt]))}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([arr i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5772, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "cljs/core.cljs", :end-column 36, :type true, :column 10, :line 5772, :record false, :end-line 5772, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8119, :column 7, :end-line 8119, :end-column 14, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, :name cljs.core/butlast, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8119, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, tail-off {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4602, :column 8, :end-line 4602, :end-column 16, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/tail-off, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4602, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, unchecked-subtract-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2421, :column 15, :end-line 2421, :end-column 37, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2421, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 729, :column 4, :end-line 729, :end-column 13, :protocol cljs.core/IIterable, :doc "Returns an iterator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 729, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an iterator for coll."}, take-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8369, :column 7, :end-line 8369, :end-column 15, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8369, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided."}, first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1069, :column 7, :end-line 1069, :end-column 12, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, :name cljs.core/first, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1069, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, native-satisfies? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 224, :column 16, :end-line 224, :end-column 33, :tag boolean, :arglists (quote ([p x])), :doc "Internal - do not use!"}, :name cljs.core/native-satisfies?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([p x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 224, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!"}, seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1971, :column 16, :end-line 1971, :end-column 20, :tag boolean, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, :name cljs.core/seq?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1971, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, -global-hierarchy {:name cljs.core/-global-hierarchy, :file "cljs/core.cljs", :line nil, :column nil, :end-line 9255, :end-column 33, :private true, :meta {:file "cljs/core.cljs", :line 9255, :column 16, :end-line 9255, :end-column 33, :private true}}, UUID {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :name cljs.core/UUID, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 9657, :record false, :end-line 9657, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, -sorted-seq-from {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 600, :column 9, :end-line 600, :end-column 25, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists (quote ([coll k ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll k ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 600, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}, println-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8787, :column 7, :end-line 8787, :end-column 18, :arglists (quote ([& objs])), :doc "println to a string, returning it", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println-str, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8787, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "println to a string, returning it"}, linear-traversal-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1591, :column 8, :end-line 1591, :end-column 28, :private true, :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/linear-traversal-nth, :variadic false, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1591, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found])}, iterate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4328, :column 7, :end-line 4328, :end-column 14, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :added "1.0"}, :added "1.0", :name cljs.core/iterate, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4328, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"}, -empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 443, :column 4, :end-line 443, :end-column 10, :protocol cljs.core/IEmptyableCollection, :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/count.", :arglists (quote ([coll]))}, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 443, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/count."}, newline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8743, :column 7, :end-line 8743, :end-column 14, :arglists (quote ([] [opts])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}}, :name cljs.core/newline, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}, :method-params ([] [opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8743, :max-fixed-arity 1, :fn-var true, :arglists ([] [opts])}, ILookup {:meta {:file "cljs/core.cljs", :line 485, :column 14, :end-line 485, :end-column 21, :doc "Protocol for looking up a value in a data structure.", :protocol-symbol true, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}}, :protocol-symbol true, :name cljs.core/ILookup, :file "cljs/core.cljs", :end-column 21, :column nil, :line nil, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 485, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/TransientHashMap cljs.core/TaggedLiteral cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :doc "Protocol for looking up a value in a data structure."}, -chunked-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 693, :column 4, :end-line 693, :end-column 17, :protocol cljs.core/IChunkedSeq, :doc "Return a new collection of coll with the first chunk removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 693, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new collection of coll with the first chunk removed."}, write-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8596, :column 7, :end-line 8596, :end-column 16, :arglists (quote ([writer & ss])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}}, :name cljs.core/write-all, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}, :method-params [(writer ss)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8596, :max-fixed-arity 1, :fn-var true, :arglists ([writer & ss])}, fn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1756, :column 16, :end-line 1756, :end-column 19, :tag boolean, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, :name cljs.core/fn?, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1756, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, -prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9421, :column 4, :end-line 9421, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val dispatch-val-y]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9421, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y])), :doc nil}, -assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 496, :column 9, :end-line 496, :end-column 15, :tag clj, :protocol cljs.core/IAssociative, :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists (quote ([coll k v]))}, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 496, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v])), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}, doall {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8506, :column 7, :end-line 8506, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/doall, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8506, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time."}, keyword-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2939, :column 16, :end-line 2939, :end-column 34, :tag boolean, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, :name cljs.core/keyword-identical?, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2939, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, *print-err-fn* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 54, :column 3, :end-line 54, :end-column 17, :doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-err-fn*, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column nil, :dynamic true, :line nil, :end-line 54, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, pv-aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4596, :column 8, :end-line 4596, :end-column 15, :private true, :arglists (quote ([node idx val]))}, :private true, :name cljs.core/pv-aset, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4596, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val]))}, prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9643, :column 7, :end-line 9643, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, :name cljs.core/prefers, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9643, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, -js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9159, :column 4, :end-line 9159, :end-column 12, :protocol cljs.core/IEncodeClojure, :doc "Transforms JavaScript values to Clojure", :arglists (quote ([x options]))}, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x options]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9159, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options])), :doc "Transforms JavaScript values to Clojure"}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 2979, :record false, :end-line 2979, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, dedupe {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9061, :column 7, :end-line 9061, :end-column 13, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/dedupe, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9061, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided."}, t5674 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t5674, :file "cljs/core.cljs", :type true, :anonymous true, :column nil, :line nil, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, unchecked-editable-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5180, :column 8, :end-line 5180, :end-column 36, :private true, :arglists (quote ([tv i]))}, :private true, :name cljs.core/unchecked-editable-array-for, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([tv i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5180, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i]))}, ->ES6Iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1121, :column 10, :end-line 1121, :end-column 21, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 1121, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 4588, :record false, :end-line 4588, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1742, :column 7, :end-line 1742, :end-column 13, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/dissoc, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params ([coll] [coll k]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 1742, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s)."}, atom {:name cljs.core/atom, :file "cljs/core.cljs", :line nil, :column nil, :end-line 6047, :end-column 72, :declared true, :meta {:file "cljs/core.cljs", :line 6047, :column 68, :end-line 6047, :end-column 72, :declared true}}, bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2536, :column 7, :end-line 2536, :end-column 22, :arglists (quote ([x n])), :doc "Bitwise shift right"}, :name cljs.core/bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2536, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right"}, *clojurescript-version* {:name cljs.core/*clojurescript-version*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 16, :end-column 29, :meta {:file "cljs/core.cljs", :line 16, :column 6, :end-line 16, :end-column 29}}, -first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 469, :column 4, :end-line 469, :end-column 10, :protocol cljs.core/ISeq, :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-first, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 469, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection coll. Used by cljs.core/first."}, peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1830, :column 7, :end-line 1830, :end-column 11, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, :name cljs.core/peek, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1830, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, IKVReduce {:meta {:file "cljs/core.cljs", :line 559, :column 14, :end-line 559, :end-column 23, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :protocol-symbol true, :protocol-info {:methods {-kv-reduce [[coll f init]]}}}, :protocol-symbol true, :name cljs.core/IKVReduce, :file "cljs/core.cljs", :end-column 23, :column nil, :line nil, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 559, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap}, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."}, aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 363, :column 7, :end-line 363, :end-column 11, :arglists (quote ([array i] [array i & idxs])), :doc "Returns the value at the index.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array i]), :arglists ([array i] [array i & idxs]), :arglists-meta (nil nil)}}, :name cljs.core/aget, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array i]), :arglists ([array i] [array i & idxs]), :arglists-meta (nil nil)}, :method-params ([array i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 363, :max-fixed-arity 2, :fn-var true, :arglists ([array i] [array i & idxs]), :doc "Returns the value at the index."}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "cljs/core.cljs", :end-column 30, :type true, :column 10, :line 6920, :record false, :end-line 6920, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 614, :column 4, :end-line 614, :end-column 10, :protocol cljs.core/IWriter, :doc "Writes s with writer and returns the result.", :arglists (quote ([writer s]))}, :protocol cljs.core/IWriter, :name cljs.core/-write, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 614, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s])), :doc "Writes s with writer and returns the result."}, iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3548, :column 7, :end-line 3548, :end-column 11, :arglists (quote ([coll]))}, :name cljs.core/iter, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3548, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, mk-bound-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8223, :column 7, :end-line 8223, :end-column 18, :arglists (quote ([sc test key]))}, :name cljs.core/mk-bound-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sc test key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8223, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key]))}, last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1531, :column 7, :end-line 1531, :end-column 11, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, :name cljs.core/last, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1531, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, -default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9425, :column 4, :end-line 9425, :end-column 25, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-default-dispatch-val, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9425, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, pr {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8760, :column 7, :end-line 8760, :end-column 9, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr, :variadic true, :file "cljs/core.cljs", :end-column 9, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8760, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader"}, tree-map-seq-push {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6913, :column 8, :end-line 6913, :end-column 25, :private true, :arglists (quote ([node stack ascending?]))}, :private true, :name cljs.core/tree-map-seq-push, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6913, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?]))}, namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2957, :column 7, :end-line 2957, :end-column 16, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, :name cljs.core/namespace, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2957, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, empty-unordered-hash {:name cljs.core/empty-unordered-hash, :file "cljs/core.cljs", :line nil, :column nil, :end-line 1195, :end-column 36, :private true, :meta {:file "cljs/core.cljs", :line 1195, :column 16, :end-line 1195, :end-column 36, :private true}}, obj-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7601, :column 7, :end-line 7601, :end-column 14, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/obj-map, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 7601, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new object map with supplied mappings."}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1244, :record false, :end-line 1244, :skip-protocol-flag #{cljs.core/IDeref}}, ->t5671 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([nil-iter meta5672])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t5671, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta5672]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column nil, :factory :positional, :line nil, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta5672])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, -conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 449, :column 9, :end-line 449, :end-column 14, :tag clj, :protocol cljs.core/ICollection, :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists (quote ([coll o]))}, :protocol cljs.core/ICollection, :name cljs.core/-conj, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll o]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 449, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o])), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 6541, :record false, :end-line 6541, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1102, :column 16, :end-line 1102, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/=, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1102, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison."}, ITransientMap {:meta {:file "cljs/core.cljs", :line 661, :column 14, :end-line 661, :end-column 27, :doc "Protocol for adding mapping functionality to transient collections.", :protocol-symbol true, :protocol-info {:methods {-dissoc! [[tcoll key]]}}}, :protocol-symbol true, :name cljs.core/ITransientMap, :file "cljs/core.cljs", :end-column 27, :column nil, :line nil, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 661, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding mapping functionality to transient collections."}, push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4618, :column 8, :end-line 4618, :end-column 17, :private true, :arglists (quote ([pv level parent tailnode]))}, :private true, :name cljs.core/push-tail, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv level parent tailnode]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4618, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode]))}, take {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4214, :column 7, :end-line 4214, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4214, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided."}, vector? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1907, :column 16, :end-line 1907, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, :name cljs.core/vector?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1907, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, array-index-of-equiv? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5670, :column 8, :end-line 5670, :end-column 29, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-equiv?, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5670, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, bitmap-indexed-node-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6073, :column 8, :end-line 6073, :end-column 33, :private true, :arglists (quote ([bitmap bit]))}, :private true, :name cljs.core/bitmap-indexed-node-index, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([bitmap bit]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6073, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit]))}, boolean {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1983, :column 16, :end-line 1983, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Coerce to boolean"}, :name cljs.core/boolean, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1983, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Coerce to boolean"}, IChunk {:meta {:file "cljs/core.cljs", :line 684, :column 14, :end-line 684, :end-column 20, :doc "Protocol for accessing the items of a chunk.", :protocol-symbol true, :protocol-info {:methods {-drop-first [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunk, :file "cljs/core.cljs", :end-column 20, :column nil, :line nil, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 684, :impls #{cljs.core/ArrayChunk}, :doc "Protocol for accessing the items of a chunk."}, bit-shift-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2532, :column 7, :end-line 2532, :end-column 21, :arglists (quote ([x n])), :doc "Bitwise shift left"}, :name cljs.core/bit-shift-left, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2532, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left"}, random-uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9684, :column 7, :end-line 9684, :end-column 18, :arglists (quote ([]))}, :name cljs.core/random-uuid, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9684, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, rand-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9228, :column 7, :end-line 9228, :end-column 15, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, :name cljs.core/rand-int, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9228, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, aclone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 340, :column 7, :end-line 340, :end-column 13, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, :name cljs.core/aclone, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 340, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, BlackNode {:meta {:file "cljs/core.cljs", :line 6976, :column 18, :end-line 6976, :end-column 27, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 7079, :record false, :declared true, :end-line 7079, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4048, :column 7, :end-line 4048, :end-column 14, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, :name cljs.core/vreset!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([vol newval]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4048, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3168, :column 7, :end-line 3168, :end-column 12, :arglists (quote ([b]))}, :name cljs.core/chunk, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3168, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2314, :column 7, :end-line 2314, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one less than num."}, :name cljs.core/dec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2314, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num."}, ->t5674 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([nil-iter meta5675])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t5674, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta5675]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column nil, :factory :positional, :line nil, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta5675])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4167, :column 7, :end-line 4167, :end-column 10, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/map, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column nil, :line nil, :end-line 4167, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided."}, juxt {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8457, :column 7, :end-line 8457, :end-column 11, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([f] [f g] [f g h]), :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/juxt, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([f] [f g] [f g h]), :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}, :method-params ([f] [f g] [f g h]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 8457, :max-fixed-arity 3, :fn-var true, :arglists ([f] [f g] [f g h] [f g h & fs]), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]"}, ->t7376 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([nil-iter meta7377])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t7376, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta7377]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column nil, :factory :positional, :line nil, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta7377])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, < {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2266, :column 16, :end-line 2266, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2266, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false."}, inode-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6090, :column 8, :end-line 6090, :end-column 23, :private true, :arglists (quote ([arr f init]))}, :private true, :name cljs.core/inode-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr f init]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6090, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init]))}, obj-map->hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5472, :column 8, :end-line 5472, :end-column 25, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/obj-map->hash-map, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5472, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9784, :column 7, :end-line 9784, :end-column 11, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, :name cljs.core/test, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9784, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1080, :column 12, :end-line 1080, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, :name cljs.core/rest, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag seq, :end-line 1080, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, ex-data {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9747, :column 7, :end-line 9747, :end-column 14, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-data, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9747, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 5711, :record false, :end-line 5711, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 686, :column 4, :end-line 686, :end-column 15, :protocol cljs.core/IChunk, :doc "Return a new chunk of coll with the first item removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 686, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new chunk of coll with the first item removed."}, isa? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9265, :column 16, :end-line 9265, :end-column 20, :tag boolean, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([child parent] [h child parent]), :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}}, :name cljs.core/isa?, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([child parent] [h child parent]), :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}, :method-params ([child parent] [h child parent]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 9265, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists ([child parent] [h child parent]), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy"}, -clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 433, :column 9, :end-line 433, :end-column 15, :tag clj, :protocol cljs.core/ICloneable, :doc "Creates a clone of value.", :arglists (quote ([value]))}, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 433, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value])), :doc "Creates a clone of value."}, munge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9888, :column 7, :end-line 9888, :end-column 12, :arglists (quote ([name]))}, :name cljs.core/munge, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9888, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, empty-ordered-hash {:name cljs.core/empty-ordered-hash, :file "cljs/core.cljs", :line nil, :column nil, :end-line 1180, :end-column 34, :private true, :meta {:file "cljs/core.cljs", :line 1180, :column 16, :end-line 1180, :end-column 34, :private true}}, DEMUNGE_MAP {:name cljs.core/DEMUNGE_MAP, :file "cljs/core.cljs", :line nil, :column nil, :end-line 302, :end-column 14, :jsdoc ["@enum {string}"], :meta {:file "cljs/core.cljs", :line 302, :column 3, :end-line 302, :end-column 14, :jsdoc ["@enum {string}"]}}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 1137, :record false, :end-line 1137, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5427, :column 10, :end-line 5427, :end-column 20, :protocols #{cljs.core/IEquiv cljs.core/Object}, :skip-protocol-flag #{cljs.core/IEquiv}, :factory :positional, :arglists (quote ([]))}, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5427, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}}, re-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8553, :column 7, :end-line 8553, :end-column 13, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, :name cljs.core/re-seq, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8553, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, char? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 218, :column 16, :end-line 218, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript char."}, :name cljs.core/char?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 218, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript char."}, make-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9251, :column 7, :end-line 9251, :end-column 21, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, :name cljs.core/make-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9251, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, Symbol {:meta {:file "cljs/core.cljs", :line 814, :column 15, :end-line 814, :end-column 21, :declared true}, :num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 910, :record false, :declared true, :end-line 910, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, tv-push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5154, :column 8, :end-line 5154, :end-column 20, :private true, :arglists (quote ([tv level parent tail-node]))}, :private true, :name cljs.core/tv-push-tail, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([tv level parent tail-node]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5154, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node]))}, -reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 554, :column 4, :end-line 554, :end-column 11, :protocol cljs.core/IReduce, :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists (quote ([coll f] [coll f start])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f start]), :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}}, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f start]), :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}, :method-params ([coll f] [coll f start]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 554, :max-fixed-arity 3, :fn-var true, :arglists ([coll f] [coll f start]), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}, -count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 438, :column 12, :end-line 438, :end-column 18, :tag number, :protocol cljs.core/ICounted, :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists (quote ([coll]))}, :protocol cljs.core/ICounted, :name cljs.core/-count, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 438, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Calculates the count of coll in constant time. Used by cljs.core/count."}, keep {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3888, :column 7, :end-line 3888, :end-column 11, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3888, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided."}, char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2334, :column 7, :end-line 2334, :end-column 11, :arglists (quote ([x])), :doc "Coerce to char"}, :name cljs.core/char, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2334, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char"}, mapcat {:protocol-inline nil, :meta {:added "1.0", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :column 7, :line 4382, :end-line 4382, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, :added "1.0", :name cljs.core/mapcat, :variadic true, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4382, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & colls]), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, unchecked-long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2448, :column 7, :end-line 2448, :end-column 21, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/unchecked-long, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2448, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, m3-seed {:name cljs.core/m3-seed, :file "cljs/core.cljs", :line nil, :column nil, :end-line 772, :end-column 13, :meta {:file "cljs/core.cljs", :line 772, :column 6, :end-line 772, :end-column 13}}, some? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 202, :column 16, :end-line 202, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, :name cljs.core/some?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 202, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, unchecked-negate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2403, :column 7, :end-line 2403, :end-column 23, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2403, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, symbol-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2948, :column 16, :end-line 2948, :end-column 33, :tag boolean, :arglists (quote ([x y])), :doc "Efficient test to determine that two symbol are identical."}, :name cljs.core/symbol-identical?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2948, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two symbol are identical."}, reverse {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2810, :column 7, :end-line 2810, :end-column 14, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, :name cljs.core/reverse, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2810, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8360, :column 7, :end-line 8360, :end-column 12, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/range, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 8360, :max-fixed-arity 3, :fn-var true, :arglists ([] [end] [start end] [start end step]), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity."}, bit-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2548, :column 7, :end-line 2548, :end-column 16, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, :name cljs.core/bit-count, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2548, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, create-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6523, :column 8, :end-line 6523, :end-column 19, :private true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :top-fn {:variadic false, :max-fixed-arity 7, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-node, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 7, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6523, :max-fixed-arity 7, :fn-var true, :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])}, sort {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2099, :column 7, :end-line 2099, :end-column 11, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [comp coll]), :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [comp coll]), :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}, :method-params ([coll] [comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2099, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [comp coll]), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ->MetaFn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1761, :column 10, :end-line 1761, :end-column 16, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([afn meta]))}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([afn meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 1761, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, unchecked-inc-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2386, :column 7, :end-line 2386, :end-column 24, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2386, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 680, :column 12, :end-line 680, :end-column 20, :tag number, :protocol cljs.core/IComparable, :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists (quote ([x y]))}, :protocol cljs.core/IComparable, :name cljs.core/-compare, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 680, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}, map-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3861, :column 7, :end-line 3861, :end-column 18, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/map-indexed, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3861, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item."}, array-list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8170, :column 7, :end-line 8170, :end-column 17, :arglists (quote ([]))}, :name cljs.core/array-list, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8170, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, rand-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9232, :column 7, :end-line 9232, :end-column 15, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, :name cljs.core/rand-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9232, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, comp {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3778, :column 7, :end-line 3778, :end-column 11, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([] [f] [f g] [f g h]), :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/comp, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([] [f] [f g] [f g h]), :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}, :method-params ([] [f] [f g] [f g h]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column nil, :line nil, :end-line 3778, :max-fixed-arity 3, :fn-var true, :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc."}, array-chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3088, :column 7, :end-line 3088, :end-column 18, :arglists (quote ([arr] [arr off] [arr off end])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([arr] [arr off] [arr off end]), :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}}, :name cljs.core/array-chunk, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([arr] [arr off] [arr off end]), :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}, :method-params ([arr] [arr off] [arr off end]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 3088, :max-fixed-arity 3, :fn-var true, :arglists ([arr] [arr off] [arr off end])}, dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9651, :column 7, :end-line 9651, :end-column 18, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, :name cljs.core/dispatch-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9651, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, bit-shift-right-zero-fill {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2540, :column 7, :end-line 2540, :end-column 32, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, :name cljs.core/bit-shift-right-zero-fill, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2540, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, js-reserved? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9853, :column 8, :end-line 9853, :end-column 20, :private true, :arglists (quote ([x]))}, :private true, :name cljs.core/js-reserved?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9853, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -as-transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 645, :column 9, :end-line 645, :end-column 22, :tag clj, :protocol cljs.core/IEditableCollection, :doc "Returns a new, transient version of the collection, in constant time.", :arglists (quote ([coll]))}, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 645, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, dorun {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8493, :column 7, :end-line 8493, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/dorun, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8493, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil."}, pr-sequential-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8573, :column 7, :end-line 8573, :end-column 27, :arglists (quote ([writer print-one begin sep end opts coll]))}, :name cljs.core/pr-sequential-writer, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8573, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll]))}, accumulating-seq-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1564, :column 8, :end-line 1564, :end-column 30, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/accumulating-seq-count, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1564, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IIndexed {:meta {:file "cljs/core.cljs", :line 458, :column 14, :end-line 458, :end-column 22, :doc "Protocol for collections to provide idexed-based access to their items.", :protocol-symbol true, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}}, :protocol-symbol true, :name cljs.core/IIndexed, :file "cljs/core.cljs", :end-column 22, :column nil, :line nil, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 458, :impls #{cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}, :doc "Protocol for collections to provide idexed-based access to their items."}, disj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1845, :column 7, :end-line 1845, :end-column 11, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/disj, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params ([coll] [coll k]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 1845, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, IPrintWithWriter {:meta {:file "cljs/core.cljs", :line 619, :column 14, :end-line 619, :end-column 30, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :protocol-symbol true, :protocol-info {:methods {-pr-writer [[o writer opts]]}}}, :protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "cljs/core.cljs", :end-column 30, :column nil, :line nil, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 619, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ExceptionInfo cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."}, ->UUID {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9657, :column 10, :end-line 9657, :end-column 14, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}, :factory :positional, :arglists (quote ([uuid __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable}, :name cljs.core/->UUID, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([uuid __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 9657, :max-fixed-arity 2, :fn-var true, :arglists (quote ([uuid __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, IVector {:meta {:file "cljs/core.cljs", :line 528, :column 14, :end-line 528, :end-column 21, :doc "Protocol for adding vector functionality to collections.", :protocol-symbol true, :protocol-info {:methods {-assoc-n [[coll n val]]}}}, :protocol-symbol true, :name cljs.core/IVector, :file "cljs/core.cljs", :end-column 21, :column nil, :line nil, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 528, :impls #{cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for adding vector functionality to collections."}, IIterable {:meta {:file "cljs/core.cljs", :line 727, :column 14, :end-line 727, :end-column 23, :doc "Protocol for iterating over a collection.", :protocol-symbol true, :protocol-info {:methods {-iterator [[coll]]}}}, :protocol-symbol true, :name cljs.core/IIterable, :file "cljs/core.cljs", :end-column 23, :column nil, :line nil, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 727, :impls #{cljs.core/PersistentArrayMap cljs.core/IndexedSeq cljs.core/PersistentVector cljs.core/Range}, :doc "Protocol for iterating over a collection."}, *2 {:name cljs.core/*2, :file "cljs/core.cljs", :line nil, :column nil, :end-line 153, :end-column 5, :doc "bound in a repl thread to the second most recent value printed", :meta {:file "cljs/core.cljs", :line 153, :column 3, :end-line 153, :end-column 5, :doc "bound in a repl thread to the second most recent value printed"}}, Eduction {:num-fields 2, :protocols #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 9088, :record false, :end-line 9088, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4599, :column 8, :end-line 4599, :end-column 21, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/pv-clone-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4599, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2883, :column 7, :end-line 2883, :end-column 11, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest."}, :name cljs.core/cons, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2883, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and seq is the rest."}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7943, :record false, :end-line 7943, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, ns-lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9921, :column 8, :end-line 9921, :end-column 17, :private true, :arglists (quote ([ns-obj k]))}, :private true, :name cljs.core/ns-lookup, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ns-obj k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9921, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ns-obj k]))}, floats {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2458, :column 7, :end-line 2458, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/floats, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2458, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, TransientVector {:meta {:file "cljs/core.cljs", :line 4704, :column 44, :end-line 4704, :end-column 59, :declared true}, :num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5196, :record false, :declared true, :end-line 5196, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, pos? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2568, :column 16, :end-line 2568, :end-column 20, :tag boolean, :arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false"}, :name cljs.core/pos?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2568, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is greater than zero, else false"}, fnil {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3836, :column 7, :end-line 3836, :end-column 11, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f x] [f x y] [f x y z]), :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}}, :name cljs.core/fnil, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f x] [f x y] [f x y z]), :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}, :method-params ([f x] [f x y] [f x y z]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 3836, :max-fixed-arity 4, :fn-var true, :arglists ([f x] [f x y] [f x y z]), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched."}, merge-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7777, :column 7, :end-line 7777, :end-column 17, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}}, :name cljs.core/merge-with, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :method-params [(f maps)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 7777, :max-fixed-arity 1, :fn-var true, :arglists ([f & maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."}, nthrest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1675, :column 7, :end-line 1675, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, :name cljs.core/nthrest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1675, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, sequential? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1883, :column 16, :end-line 1883, :end-column 27, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, :name cljs.core/sequential?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1883, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, tree-map-replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7424, :column 8, :end-line 7424, :end-column 24, :private true, :arglists (quote ([comp tree k v]))}, :private true, :name cljs.core/tree-map-replace, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([comp tree k v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7424, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v]))}, m3-mix-H1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 779, :column 15, :end-line 779, :end-column 24, :tag number, :arglists (quote ([h1 k1]))}, :name cljs.core/m3-mix-H1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([h1 k1]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 779, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1]))}, ->TransientArrayMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5966, :column 10, :end-line 5966, :end-column 27, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([editable? len arr]))}, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([editable? len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5966, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, prim-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1434, :column 7, :end-line 1434, :end-column 15, :arglists (quote ([prim] [prim i])), :doc "Create seq from a primitive JavaScript Array-like.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prim] [prim i]), :arglists ([prim] [prim i]), :arglists-meta (nil nil)}}, :name cljs.core/prim-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prim] [prim i]), :arglists ([prim] [prim i]), :arglists-meta (nil nil)}, :method-params ([prim] [prim i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1434, :max-fixed-arity 2, :fn-var true, :arglists ([prim] [prim i]), :doc "Create seq from a primitive JavaScript Array-like."}, *print-level* {:name cljs.core/*print-level*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 122, :end-column 16, :dynamic true, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :meta {:file "cljs/core.cljs", :line 122, :column 3, :end-line 122, :end-column 16, :dynamic true, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}}, shuffle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2140, :column 7, :end-line 2140, :end-column 14, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, :name cljs.core/shuffle, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2140, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, ChunkedSeq {:meta {:file "cljs/core.cljs", :line 1911, :column 22, :end-line 1911, :end-column 32, :declared true}, :num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 4929, :record false, :declared true, :end-line 4929, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, hash-keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2891, :column 7, :end-line 2891, :end-column 19, :arglists (quote ([k]))}, :name cljs.core/hash-keyword, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2891, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2015, :column 7, :end-line 2015, :end-column 11, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, :name cljs.core/find, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2015, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, alength {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 377, :column 15, :end-line 377, :end-column 22, :tag number, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, :name cljs.core/alength, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([array]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 377, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, bit-xor {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2484, :column 7, :end-line 2484, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise exclusive or", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-xor, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2484, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise exclusive or"}, ->IndexedSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1361, :column 10, :end-line 1361, :end-column 20, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 1361, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ICloneable cljs.core/ISequential cljs.core/IReduce}}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 5496, :record false, :end-line 5496, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2544, :column 7, :end-line 2544, :end-column 31, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, :name cljs.core/unsigned-bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2544, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 5620, :record false, :end-line 5620, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2577, :column 16, :end-line 2577, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, :name cljs.core/neg?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2577, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 2834, :record false, :end-line 2834, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9420, :column 4, :end-line 9420, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9420, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->StringIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3500, :column 10, :end-line 3500, :end-column 20, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3500, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil}, js-invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 392, :column 7, :end-line 392, :end-column 16, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}}, :name cljs.core/js-invoke, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}, :method-params [(obj s args)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 392, :max-fixed-arity 2, :fn-var true, :arglists ([obj s & args]), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name."}, ->List {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2673, :column 10, :end-line 2673, :end-column 14, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta first rest count __hash]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 2673, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, m3-mix-K1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 776, :column 15, :end-line 776, :end-column 24, :tag number, :arglists (quote ([k1]))}, :name cljs.core/m3-mix-K1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([k1]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 776, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1]))}, unchecked-float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2349, :column 15, :end-line 2349, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-float, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2349, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, undefined? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1966, :column 16, :end-line 1966, :end-column 26, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, :name cljs.core/undefined?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1966, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, IMeta {:meta {:file "cljs/core.cljs", :line 541, :column 14, :end-line 541, :end-column 19, :doc "Protocol for accessing the metadata of an object.", :protocol-symbol true, :protocol-info {:methods {-meta [[o]]}}}, :protocol-symbol true, :name cljs.core/IMeta, :file "cljs/core.cljs", :end-column 19, :column nil, :line nil, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 541, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/t7373 cljs.core/RSeq cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/t7376 cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for accessing the metadata of an object."}, reduced? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1253, :column 16, :end-line 1253, :end-column 24, :tag boolean, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, :name cljs.core/reduced?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([r]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1253, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, apply-to {:protocol-inline nil, :meta {:arglists (quote ([f argc args])), :file "cljs/core.cljs"}, :name cljs.core/apply-to, :variadic false, :file "cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args]))}, disj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3400, :column 7, :end-line 3400, :end-column 12, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll val]), :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}}, :name cljs.core/disj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll val]), :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3400, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll val] [tcoll val & vals]), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, -lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 487, :column 4, :end-line 487, :end-column 11, :protocol cljs.core/ILookup, :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists (quote ([o k] [o k not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 487, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}, ICloneable {:meta {:file "cljs/core.cljs", :line 431, :column 14, :end-line 431, :end-column 24, :doc "Protocol for cloning a value.", :protocol-symbol true, :protocol-info {:methods {-clone [[value]]}}}, :protocol-symbol true, :name cljs.core/ICloneable, :file "cljs/core.cljs", :end-column 24, :column nil, :line nil, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 431, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}, :doc "Protocol for cloning a value."}, IEncodeClojure {:meta {:file "cljs/core.cljs", :line 9158, :column 14, :end-line 9158, :end-column 28, :doc nil, :protocol-symbol true, :protocol-info {:methods {-js->clj [[x options]]}}}, :protocol-symbol true, :name cljs.core/IEncodeClojure, :file "cljs/core.cljs", :end-column 28, :column nil, :line nil, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 9158, :impls #{}, :doc nil}, booleans {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2453, :column 7, :end-line 2453, :end-column 15, :arglists (quote ([x]))}, :name cljs.core/booleans, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2453, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ArrayList {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8162, :column 10, :end-line 8162, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 8162, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil}, RSeq {:meta {:file "cljs/core.cljs", :line 1342, :column 25, :end-line 1342, :end-column 29, :declared true}, :num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 1451, :record false, :declared true, :end-line 1451, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, mask {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6055, :column 8, :end-line 6055, :end-column 12, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/mask, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6055, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, int-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3205, :column 7, :end-line 3205, :end-column 16, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/int-array, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3205, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure."}, find-and-cache-best-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9392, :column 8, :end-line 9392, :end-column 34, :private true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, :private true, :name cljs.core/find-and-cache-best-method, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9392, :max-fixed-arity 7, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, set? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1872, :column 16, :end-line 1872, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, :name cljs.core/set?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1872, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, iterable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1031, :column 7, :end-line 1031, :end-column 16, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, :name cljs.core/iterable?, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1031, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, cat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9049, :column 7, :end-line 9049, :end-column 10, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :added "1.7"}, :added "1.7", :name cljs.core/cat, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9049, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction."}, ->ES6EntriesIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5607, :column 10, :end-line 5607, :end-column 28, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5607, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, divide {:name cljs.core/divide, :file "cljs/core.cljs", :line nil, :column nil, :end-line 2257, :end-column 16, :declared true, :meta {:file "cljs/core.cljs", :line 2257, :column 10, :end-line 2257, :end-column 16, :declared true}}, js-reserved-arr {:name cljs.core/js-reserved-arr, :file "cljs/core.cljs", :line nil, :column nil, :end-line 9836, :end-column 31, :private true, :meta {:file "cljs/core.cljs", :line 9836, :column 16, :end-line 9836, :end-column 31, :private true}}, -pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 625, :column 4, :end-line 625, :end-column 14, :protocol cljs.core/IPrintWithWriter, :doc nil, :arglists (quote ([o writer opts]))}, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([o writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 625, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts])), :doc nil}, flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8604, :column 7, :end-line 8604, :end-column 12, :arglists (quote ([]))}, :name cljs.core/flush, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8604, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, set-from-indexed-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8036, :column 7, :end-line 8036, :end-column 27, :arglists (quote ([iseq]))}, :name cljs.core/set-from-indexed-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([iseq]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8036, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq]))}, take-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8204, :column 7, :end-line 8204, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8204, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, vary-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3466, :column 7, :end-line 3466, :end-column 16, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}}, :name cljs.core/vary-meta, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil), :column nil, :line nil, :end-line 3466, :max-fixed-arity 6, :fn-var true, :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata."}, INext {:meta {:file "cljs/core.cljs", :line 477, :column 14, :end-line 477, :end-column 19, :doc "Protocol for accessing the next items of a collection.", :protocol-symbol true, :protocol-info {:methods {-next [[coll]]}}}, :protocol-symbol true, :name cljs.core/INext, :file "cljs/core.cljs", :end-column 19, :column nil, :line nil, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 477, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range}, :doc "Protocol for accessing the next items of a collection."}, is_proto_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 234, :column 7, :end-line 234, :end-column 16, :arglists (quote ([x]))}, :name cljs.core/is_proto_, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 234, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, START {:name cljs.core/START, :file "cljs/core.cljs", :line nil, :column nil, :end-line 3525, :end-column 11, :meta {:file "cljs/core.cljs", :line 3525, :column 6, :end-line 3525, :end-column 11}}, ICounted {:meta {:file "cljs/core.cljs", :line 436, :column 14, :end-line 436, :end-column 22, :doc "Protocol for adding the ability to count a collection in constant time.", :protocol-symbol true, :protocol-info {:methods {-count [[coll]]}}}, :protocol-symbol true, :name cljs.core/ICounted, :file "cljs/core.cljs", :end-column 22, :column nil, :line nil, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 436, :impls #{nil cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to count a collection in constant time."}, IMapEntry {:meta {:file "cljs/core.cljs", :line 506, :column 14, :end-line 506, :end-column 23, :doc "Protocol for examining a map entry.", :protocol-symbol true, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}}, :protocol-symbol true, :name cljs.core/IMapEntry, :file "cljs/core.cljs", :end-column 23, :column nil, :line nil, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 506, :impls #{cljs.core/BlackNode cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for examining a map entry."}, <= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2278, :column 16, :end-line 2278, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<=, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2278, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false."}, conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3359, :column 7, :end-line 3359, :end-column 12, :arglists (quote ([] [coll] [tcoll val] [tcoll val & vals])), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [tcoll val]), :arglists ([] [coll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [tcoll val]), :arglists ([] [coll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}, :method-params ([] [coll] [tcoll val]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 3359, :max-fixed-arity 2, :fn-var true, :arglists ([] [coll] [tcoll val] [tcoll val & vals]), :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type."}, -pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 524, :column 9, :end-line 524, :end-column 13, :tag clj, :protocol cljs.core/IStack, :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-pop, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 524, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}, array-index-of-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5662, :column 8, :end-line 5662, :end-column 33, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-identical?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5662, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, repeatedly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4321, :column 7, :end-line 4321, :end-column 17, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [n f]), :arglists ([f] [n f]), :arglists-meta (nil nil)}}, :name cljs.core/repeatedly, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [n f]), :arglists ([f] [n f]), :arglists-meta (nil nil)}, :method-params ([f] [n f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4321, :max-fixed-arity 2, :fn-var true, :arglists ([f] [n f]), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it"}, zipmap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8136, :column 7, :end-line 8136, :end-column 13, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, :name cljs.core/zipmap, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([keys vals]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8136, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, IStack {:meta {:file "cljs/core.cljs", :line 518, :column 14, :end-line 518, :end-column 20, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :protocol-symbol true, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}}, :protocol-symbol true, :name cljs.core/IStack, :file "cljs/core.cljs", :end-column 20, :column nil, :line nil, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 518, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."}, -remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 640, :column 4, :end-line 640, :end-column 17, :protocol cljs.core/IWatchable, :doc "Removes watcher that corresponds to key from this.", :arglists (quote ([this key]))}, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([this key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 640, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key])), :doc "Removes watcher that corresponds to key from this."}, IVolatile {:meta {:file "cljs/core.cljs", :line 721, :column 14, :end-line 721, :end-column 23, :doc "Protocol for adding volatile functionality.", :protocol-symbol true, :protocol-info {:methods {-vreset! [[o new-value]]}}}, :protocol-symbol true, :name cljs.core/IVolatile, :file "cljs/core.cljs", :end-column 23, :column nil, :line nil, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 721, :impls #{cljs.core/Volatile}, :doc "Protocol for adding volatile functionality."}, remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4421, :column 7, :end-line 4421, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/remove, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4421, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->BitmapIndexedNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6108, :column 10, :end-line 6108, :end-column 27, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit bitmap arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->BitmapIndexedNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit bitmap arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6108, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag nil}, * {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2250, :column 15, :end-line 2250, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/*, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2250, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, re-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8562, :column 7, :end-line 8562, :end-column 17, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, :name cljs.core/re-pattern, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8562, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, min {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2325, :column 15, :end-line 2325, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2325, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the least of the nums."}, array-index-of-nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5634, :column 8, :end-line 5634, :end-column 27, :private true, :arglists (quote ([arr]))}, :private true, :name cljs.core/array-index-of-nil?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5634, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr]))}, -persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 652, :column 9, :end-line 652, :end-column 21, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Creates a persistent data structure from tcoll and returns it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 652, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Creates a persistent data structure from tcoll and returns it."}, -nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 460, :column 4, :end-line 460, :end-column 8, :protocol cljs.core/IIndexed, :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :variadic false, :file "cljs/core.cljs", :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 460, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}, pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3394, :column 7, :end-line 3394, :end-column 11, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll"}, :name cljs.core/pop!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3394, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll"}, chunk-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3165, :column 7, :end-line 3165, :end-column 19, :arglists (quote ([b x]))}, :name cljs.core/chunk-append, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([b x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3165, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x]))}, prn-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8755, :column 7, :end-line 8755, :end-column 14, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn-str, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8755, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr-str followed by (newline)"}, IReversible {:meta {:file "cljs/core.cljs", :line 590, :column 14, :end-line 590, :end-column 25, :doc "Protocol for reversing a seq.", :protocol-symbol true, :protocol-info {:methods {-rseq [[coll]]}}}, :protocol-symbol true, :name cljs.core/IReversible, :file "cljs/core.cljs", :end-column 25, :column nil, :line nil, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 590, :impls #{cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for reversing a seq."}, reversible? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2799, :column 16, :end-line 2799, :end-column 27, :tag boolean, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, :name cljs.core/reversible?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2799, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, -realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 630, :column 13, :end-line 630, :end-column 23, :tag boolean, :protocol cljs.core/IPending, :doc "Returns true if a value for d has been produced, false otherwise.", :arglists (quote ([d]))}, :protocol cljs.core/IPending, :name cljs.core/-realized?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 630, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value for d has been produced, false otherwise."}, -add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 637, :column 4, :end-line 637, :end-column 14, :protocol cljs.core/IWatchable, :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists (quote ([this key f]))}, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([this key f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 637, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f])), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}, -deref-with-timeout {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 539, :column 4, :end-line 539, :end-column 23, :protocol cljs.core/IDerefWithTimeout, :doc nil, :arglists (quote ([o msec timeout-val]))}, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([o msec timeout-val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 539, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val])), :doc nil}, conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1543, :column 7, :end-line 1543, :end-column 11, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [coll x]), :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [coll x]), :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}, :method-params ([] [coll] [coll x]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 1543, :max-fixed-arity 2, :fn-var true, :arglists ([] [coll] [coll x] [coll x & xs]), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type."}, -sorted-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 598, :column 9, :end-line 598, :end-column 20, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists (quote ([coll ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([coll ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 598, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order."}, flatten1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4368, :column 8, :end-line 4368, :end-column 16, :private true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, :private true, :name cljs.core/flatten1, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4368, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, transduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2217, :column 7, :end-line 2217, :end-column 16, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xform f coll] [xform f init coll]), :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/transduce, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xform f coll] [xform f init coll]), :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}, :method-params ([xform f coll] [xform f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2217, :max-fixed-arity 4, :fn-var true, :arglists ([xform f coll] [xform f init coll]), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."}, fixture1 {:name cljs.core/fixture1, :file "cljs/core.cljs", :line nil, :column nil, :end-line 9009, :end-column 14, :meta {:file "cljs/core.cljs", :line 9009, :column 6, :end-line 9009, :end-column 14}}, -swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 718, :column 4, :end-line 718, :end-column 10, :protocol cljs.core/ISwap, :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}}, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 718, :max-fixed-arity 5, :fn-var true, :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :doc "Swaps the value of o to be (apply f current-value-of-atom args)."}, *print-length* {:name cljs.core/*print-length*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 110, :end-column 17, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :meta {:file "cljs/core.cljs", :line 110, :column 3, :end-line 110, :end-column 17, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}}, js-delete {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1933, :column 7, :end-line 1933, :end-column 16, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object."}, :name cljs.core/js-delete, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1933, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object."}, truth_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 163, :column 7, :end-line 163, :end-column 13, :arglists (quote ([x])), :doc "Internal - do not use!"}, :name cljs.core/truth_, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 163, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!"}, array-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5678, :column 7, :end-line 5678, :end-column 21, :arglists (quote ([arr k]))}, :name cljs.core/array-index-of, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5678, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->MultiFn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9431, :column 10, :end-line 9431, :end-column 17, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :factory :positional, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 9431, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9127, :column 7, :end-line 9127, :end-column 14, :arglists (quote ([k]))}, :name cljs.core/key->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9127, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ->MultiStepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3591, :column 10, :end-line 3591, :end-column 22, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([xform iters nexts]))}, :protocols #{cljs.core/Object}, :name cljs.core/->MultiStepper, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3591, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters nexts])), :skip-protocol-flag nil}, IEncodeJS {:meta {:file "cljs/core.cljs", :line 9120, :column 14, :end-line 9120, :end-column 23, :doc nil, :protocol-symbol true, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}}, :protocol-symbol true, :name cljs.core/IEncodeJS, :file "cljs/core.cljs", :end-column 23, :column nil, :line nil, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 9120, :impls #{}, :doc nil}, new-path {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4608, :column 8, :end-line 4608, :end-column 16, :private true, :arglists (quote ([edit level node]))}, :private true, :name cljs.core/new-path, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([edit level node]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4608, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node]))}, compare-and-set! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4007, :column 7, :end-line 4007, :end-column 23, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, :name cljs.core/compare-and-set!, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4007, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, array-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1442, :column 7, :end-line 1442, :end-column 16, :arglists (quote ([array] [array i])), :doc "Create a seq from a JavaScript array.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([array] [array i]), :arglists ([array] [array i]), :arglists-meta (nil nil)}}, :name cljs.core/array-seq, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([array] [array i]), :arglists ([array] [array i]), :arglists-meta (nil nil)}, :method-params ([array] [array i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1442, :max-fixed-arity 2, :fn-var true, :arglists ([array] [array i]), :doc "Create a seq from a JavaScript array."}, array-copy-downward {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1946, :column 8, :end-line 1946, :end-column 27, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy-downward, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1946, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, pack-array-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6306, :column 8, :end-line 6306, :end-column 23, :private true, :arglists (quote ([array-node edit idx]))}, :private true, :name cljs.core/pack-array-node, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([array-node edit idx]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6306, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx]))}, interleave {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4333, :column 7, :end-line 4333, :end-column 17, :arglists (quote ([c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([c1 c2]), :arglists ([c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil)}}, :name cljs.core/interleave, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([c1 c2]), :arglists ([c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil)}, :method-params ([c1 c2]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4333, :max-fixed-arity 2, :fn-var true, :arglists ([c1 c2] [c1 c2 & colls]), :doc "Returns a lazy seq of the first item in each coll, then the second etc."}, print-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8799, :column 7, :end-line 8799, :end-column 16, :arglists (quote ([m print-one writer opts]))}, :name cljs.core/print-map, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8799, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts]))}, map? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1895, :column 16, :end-line 1895, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, :name cljs.core/map?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1895, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, m3-C1 {:name cljs.core/m3-C1, :file "cljs/core.cljs", :line nil, :column nil, :end-line 773, :end-column 11, :meta {:file "cljs/core.cljs", :line 773, :column 6, :end-line 773, :end-column 11}}, get {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1683, :column 7, :end-line 1683, :end-column 10, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :name cljs.core/get, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1683, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Returns the value mapped to key, not-found or nil if key not present."}, identity {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2202, :column 7, :end-line 2202, :end-column 15, :arglists (quote ([x])), :doc "Returns its argument."}, :name cljs.core/identity, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2202, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns its argument."}, into {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4452, :column 7, :end-line 4452, :end-column 11, :arglists (quote ([to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([to from] [to xform from]), :arglists ([to from] [to xform from]), :arglists-meta (nil nil)}}, :name cljs.core/into, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([to from] [to xform from]), :arglists ([to from] [to xform from]), :arglists-meta (nil nil)}, :method-params ([to from] [to xform from]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4452, :max-fixed-arity 3, :fn-var true, :arglists ([to from] [to xform from]), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied."}, long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2443, :column 7, :end-line 2443, :end-column 11, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/long, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2443, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2344, :column 15, :end-line 2344, :end-column 21, :tag number, :arglists (quote ([x]))}, :name cljs.core/double, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2344, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, volatile? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4044, :column 7, :end-line 4044, :end-column 16, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, :name cljs.core/volatile?, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4044, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3047, :record false, :end-line 3047, :skip-protocol-flag #{cljs.core/ICounted}}, -key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 508, :column 4, :end-line 508, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the key of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 508, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the key of the map entry."}, ->t7373 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([nil-iter meta7374])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t7373, :variadic false, :file "cljs/core.cljs", :method-params ([nil-iter meta7374]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column nil, :factory :positional, :line nil, :max-fixed-arity 2, :fn-var true, :arglists (quote ([nil-iter meta7374])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, nfirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1516, :column 7, :end-line 1516, :end-column 13, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, :name cljs.core/nfirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1516, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 734, :record false, :end-line 734, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1823, :column 7, :end-line 1823, :end-column 11, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, :name cljs.core/meta, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1823, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, tv-editable-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5149, :column 8, :end-line 5149, :end-column 24, :private true, :arglists (quote ([tl]))}, :private true, :name cljs.core/tv-editable-tail, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([tl]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5149, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl]))}, -kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 562, :column 4, :end-line 562, :end-column 14, :protocol cljs.core/IKVReduce, :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists (quote ([coll f init]))}, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 562, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}, IHash {:meta {:file "cljs/core.cljs", :line 571, :column 14, :end-line 571, :end-column 19, :doc "Protocol for adding hashing functionality to a type.", :protocol-symbol true, :protocol-info {:methods {-hash [[o]]}}}, :protocol-symbol true, :name cljs.core/IHash, :file "cljs/core.cljs", :end-column 19, :column nil, :line nil, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 571, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding hashing functionality to a type."}, bit-and-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2502, :column 7, :end-line 2502, :end-column 18, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and-not, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2502, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and"}, var? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1022, :column 7, :end-line 1022, :end-column 11, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, :name cljs.core/var?, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1022, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, -comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 609, :column 4, :end-line 609, :end-column 15, :protocol cljs.core/ISorted, :doc "Returns the comparator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 609, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the comparator for coll."}, unchecked-add-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2359, :column 15, :end-line 2359, :end-column 32, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add-int, :variadic true, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2359, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, hash-ordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1169, :column 15, :end-line 1169, :end-column 32, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-ordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 1169, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, extend-object! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2661, :column 8, :end-line 2661, :end-column 22, :private true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, :private true, :name cljs.core/extend-object!, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj fn-map]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2661, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, do-assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4661, :column 8, :end-line 4661, :end-column 16, :private true, :arglists (quote ([pv level node i val]))}, :private true, :name cljs.core/do-assoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node i val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4661, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val]))}, reset-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8955, :column 7, :end-line 8955, :end-column 18, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, :name cljs.core/reset-meta!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([iref m]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8955, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, ->KeySeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7633, :column 10, :end-line 7633, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([mseq _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 7633, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IEquiv {:meta {:file "cljs/core.cljs", :line 566, :column 14, :end-line 566, :end-column 20, :doc "Protocol for adding value comparison functionality to a type.", :protocol-symbol true, :protocol-info {:methods {-equiv [[o other]]}}}, :protocol-symbol true, :name cljs.core/IEquiv, :file "cljs/core.cljs", :end-column 20, :column nil, :line nil, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 566, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding value comparison functionality to a type."}, tree-map-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7063, :column 8, :end-line 7063, :end-column 26, :private true, :arglists (quote ([node f init]))}, :private true, :name cljs.core/tree-map-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7063, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init]))}, cycle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4301, :column 7, :end-line 4301, :end-column 12, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, :name cljs.core/cycle, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4301, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, -deref {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 535, :column 4, :end-line 535, :end-column 10, :protocol cljs.core/IDeref, :doc "Returns the value of the reference o.", :arglists (quote ([o]))}, :protocol cljs.core/IDeref, :name cljs.core/-deref, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 535, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the value of the reference o."}, pr-writer-ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9699, :column 8, :end-line 9699, :end-column 25, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-ex-info, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9699, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, empty? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1859, :column 16, :end-line 1859, :end-column 22, :tag boolean, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, :name cljs.core/empty?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1859, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, TaggedLiteral {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/TaggedLiteral, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 9794, :record false, :end-line 9794, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2342, :column 15, :end-line 2342, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/short, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2342, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, -clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9121, :column 4, :end-line 9121, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Recursively transforms clj values to JavaScript", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9121, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms clj values to JavaScript"}, -chunked-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 691, :column 4, :end-line 691, :end-column 18, :protocol cljs.core/IChunkedSeq, :doc "Returns the first chunk in coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 691, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first chunk in coll."}, filterv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4482, :column 7, :end-line 4482, :end-column 14, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, :name cljs.core/filterv, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4482, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, ->TaggedLiteral {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9794, :column 10, :end-line 9794, :end-column 23, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}, :factory :positional, :arglists (quote ([tag form]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/->TaggedLiteral, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 9794, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, tv-editable-root {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5146, :column 8, :end-line 5146, :end-column 24, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/tv-editable-root, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5146, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 847, :column 7, :end-line 847, :end-column 11, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, :name cljs.core/hash, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 847, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, quot {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2472, :column 7, :end-line 2472, :end-column 11, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, :name cljs.core/quot, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2472, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, ns-interns* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9962, :column 7, :end-line 9962, :end-column 18, :arglists (quote ([sym]))}, :name cljs.core/ns-interns*, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9962, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, unchecked-double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2350, :column 15, :end-line 2350, :end-column 31, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-double, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2350, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, *target* {:meta {:file "cljs/core.cljs", :line 27, :column 3, :end-line 27, :end-column 11, :dynamic true, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :jsdoc ["@define {string}"]}, :name cljs.core/*target*, :file "cljs/core.cljs", :end-column 11, :column nil, :dynamic true, :line nil, :end-line 27, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :jsdoc ["@define {string}"]}, ->ChunkedCons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3096, :column 10, :end-line 3096, :end-column 21, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([chunk more meta __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([chunk more meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3096, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, ranged-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4697, :column 7, :end-line 4697, :end-column 22, :arglists (quote ([v start end]))}, :name cljs.core/ranged-iterator, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4697, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end]))}, ITransientVector {:meta {:file "cljs/core.cljs", :line 666, :column 14, :end-line 666, :end-column 30, :doc "Protocol for adding vector functionality to transient collections.", :protocol-symbol true, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}}, :protocol-symbol true, :name cljs.core/ITransientVector, :file "cljs/core.cljs", :end-column 30, :column nil, :line nil, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 666, :impls #{cljs.core/TransientVector}, :doc "Protocol for adding vector functionality to transient collections."}, key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7696, :column 7, :end-line 7696, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, :name cljs.core/key, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7696, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, longs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2460, :column 7, :end-line 2460, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/longs, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2460, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, not= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3482, :column 16, :end-line 3482, :end-column 20, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/not=, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 3482, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Same as (not (= obj1 obj2))"}, set-print-err-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 62, :column 7, :end-line 62, :end-column 24, :arglists (quote ([f])), :doc "Set *print-err-fn* to f."}, :name cljs.core/set-print-err-fn!, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 62, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-err-fn* to f."}, string? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 213, :column 16, :end-line 213, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, :name cljs.core/string?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 213, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, es6-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1130, :column 7, :end-line 1130, :end-column 19, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, :name cljs.core/es6-iterator, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1130, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/Delay, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 9014, :record false, :end-line 9014, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, munge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9876, :column 8, :end-line 9876, :end-column 17, :private true, :arglists (quote ([name]))}, :private true, :name cljs.core/munge-str, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9876, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, pr-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8720, :column 7, :end-line 8720, :end-column 23, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, :name cljs.core/pr-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8720, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, m3-C2 {:name cljs.core/m3-C2, :file "cljs/core.cljs", :line nil, :column nil, :end-line 774, :end-column 11, :meta {:file "cljs/core.cljs", :line 774, :column 6, :end-line 774, :end-column 11}}, ->Symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 910, :column 10, :end-line 910, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([ns name str _hash _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 910, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, *print-newline* {:name cljs.core/*print-newline*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 78, :end-column 18, :dynamic true, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :meta {:file "cljs/core.cljs", :line 78, :column 3, :end-line 78, :end-column 18, :dynamic true, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}}, unchecked-multiply-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2396, :column 15, :end-line 2396, :end-column 37, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2396, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, chunk-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3174, :column 7, :end-line 3174, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3174, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, remove-all-methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9618, :column 7, :end-line 9618, :end-column 25, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, :name cljs.core/remove-all-methods, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9618, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, trampoline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9206, :column 7, :end-line 9206, :end-column 17, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & args]), :arglists-meta (nil nil)}}, :name cljs.core/trampoline, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & args]), :arglists-meta (nil nil)}, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9206, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & args]), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns."}, pr-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 126, :column 8, :end-line 126, :end-column 15, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/pr-opts, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 126, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *1 {:name cljs.core/*1, :file "cljs/core.cljs", :line nil, :column nil, :end-line 149, :end-column 5, :doc "bound in a repl thread to the most recent value printed", :meta {:file "cljs/core.cljs", :line 149, :column 3, :end-line 149, :end-column 5, :doc "bound in a repl thread to the most recent value printed"}}, vec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4909, :column 7, :end-line 4909, :end-column 10, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, :name cljs.core/vec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4909, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, *print-meta* {:name cljs.core/*print-meta*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 94, :end-column 15, :dynamic true, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :meta {:file "cljs/core.cljs", :line 94, :column 3, :end-line 94, :end-column 15, :dynamic true, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}}, -notify-watches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 635, :column 4, :end-line 635, :end-column 19, :protocol cljs.core/IWatchable, :doc "Calls all watchers with this, oldval and newval.", :arglists (quote ([this oldval newval]))}, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([this oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 635, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval])), :doc "Calls all watchers with this, oldval and newval."}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 9431, :record false, :end-line 9431, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2433, :column 7, :end-line 2433, :end-column 10, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/int, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2433, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, ->ValSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7701, :column 10, :end-line 7701, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([mseq _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 7701, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, rand {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9222, :column 7, :end-line 9222, :end-column 11, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}}, :name cljs.core/rand, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}, :method-params ([] [n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9222, :max-fixed-arity 1, :fn-var true, :arglists ([] [n]), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive)."}, second {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1506, :column 7, :end-line 1506, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/second, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1506, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, find-ns-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9952, :column 7, :end-line 9952, :end-column 18, :arglists (quote ([ns]))}, :name cljs.core/find-ns-obj, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9952, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns]))}, IEditableCollection {:meta {:file "cljs/core.cljs", :line 643, :column 14, :end-line 643, :end-column 33, :doc "Protocol for collections which can transformed to transients.", :protocol-symbol true, :protocol-info {:methods {-as-transient [[coll]]}}}, :protocol-symbol true, :name cljs.core/IEditableCollection, :file "cljs/core.cljs", :end-column 33, :column nil, :line nil, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 643, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}, :doc "Protocol for collections which can transformed to transients."}, hash-combine {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 873, :column 7, :end-line 873, :end-column 19, :arglists (quote ([seed hash]))}, :name cljs.core/hash-combine, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([seed hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 873, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash]))}, > {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2290, :column 16, :end-line 2290, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2290, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false."}, -name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 703, :column 12, :end-line 703, :end-column 17, :tag string, :protocol cljs.core/INamed, :doc "Returns the name String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-name, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag string, :end-line 703, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of x."}, replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8077, :column 7, :end-line 8077, :end-column 14, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([smap] [smap coll]), :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}}, :name cljs.core/replace, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([smap] [smap coll]), :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}, :method-params ([smap] [smap coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8077, :max-fixed-arity 2, :fn-var true, :arglists ([smap] [smap coll]), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided."}, ->Subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5013, :column 10, :end-line 5013, :end-column 16, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta v start end __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5013, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, associative? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1879, :column 16, :end-line 1879, :end-column 28, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, :name cljs.core/associative?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1879, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, unchecked-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2438, :column 7, :end-line 2438, :end-column 20, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/unchecked-int, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2438, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, js-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1926, :column 7, :end-line 1926, :end-column 14, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, :name cljs.core/js-keys, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1926, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5607, :record false, :end-line 5607, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2934, :column 16, :end-line 2934, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, :name cljs.core/keyword?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2934, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, array-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3521, :column 7, :end-line 3521, :end-column 17, :arglists (quote ([x]))}, :name cljs.core/array-iter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3521, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, force {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9030, :column 7, :end-line 9030, :end-column 12, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, :name cljs.core/force, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9030, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, group-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9239, :column 7, :end-line 9239, :end-column 15, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, :name cljs.core/group-by, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9239, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, -rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 592, :column 9, :end-line 592, :end-column 14, :tag clj, :protocol cljs.core/IReversible, :doc "Returns a seq of the items in coll in reversed order.", :arglists (quote ([coll]))}, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 592, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reversed order."}, prn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8792, :column 7, :end-line 8792, :end-column 10, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8792, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr followed by (newline)."}, tv-pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5166, :column 8, :end-line 5166, :end-column 19, :private true, :arglists (quote ([tv level node]))}, :private true, :name cljs.core/tv-pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([tv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5166, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node]))}, default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9647, :column 7, :end-line 9647, :end-column 27, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, :name cljs.core/default-dispatch-val, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9647, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, ->Atom {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3922, :column 10, :end-line 3922, :end-column 14, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :factory :positional, :arglists (quote ([state meta validator watches]))}, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([state meta validator watches]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3922, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, PersistentHashMap {:meta {:file "cljs/core.cljs", :line 6034, :column 27, :end-line 6034, :end-column 44, :declared true}, :num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6659, :record false, :declared true, :end-line 6659, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unchecked-multiply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2389, :column 15, :end-line 2389, :end-column 33, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply, :variadic true, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2389, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 6604, :record false, :end-line 6604, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3754, :column 16, :end-line 3754, :end-column 21, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, :name cljs.core/even?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 3754, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, es6-iterator-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1147, :column 7, :end-line 1147, :end-column 23, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, :name cljs.core/es6-iterator-seq, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1147, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, unchecked-dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2366, :column 7, :end-line 2366, :end-column 20, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2366, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, hash-collision-node-find-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6416, :column 8, :end-line 6416, :end-column 38, :private true, :arglists (quote ([arr cnt key]))}, :private true, :name cljs.core/hash-collision-node-find-index, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([arr cnt key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6416, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key]))}, persistent-array-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5766, :column 7, :end-line 5766, :end-column 31, :arglists (quote ([arr i _meta]))}, :name cljs.core/persistent-array-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5766, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta]))}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 8259, :record false, :end-line 8259, :skip-protocol-flag nil}, MultiStepper {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/MultiStepper, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 3591, :record false, :end-line 3591, :skip-protocol-flag nil}, tagged-literal? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9824, :column 7, :end-line 9824, :end-column 22, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, :name cljs.core/tagged-literal?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9824, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, double-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3249, :column 7, :end-line 3249, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/double-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3249, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure."}, create-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9972, :column 7, :end-line 9972, :end-column 16, :arglists (quote ([sym] [sym ns-obj])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sym] [sym ns-obj]), :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}}, :name cljs.core/create-ns, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sym] [sym ns-obj]), :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}, :method-params ([sym] [sym ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9972, :max-fixed-arity 2, :fn-var true, :arglists ([sym] [sym ns-obj])}, ->EmptyList {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2739, :column 10, :end-line 2739, :end-column 19, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 2739, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, seq-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2124, :column 8, :end-line 2124, :end-column 18, :private true, :arglists (quote ([f coll] [f val coll])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/seq-reduce, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2124, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll])}, spread {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3301, :column 7, :end-line 3301, :end-column 13, :arglists (quote ([arglist]))}, :name cljs.core/spread, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3301, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist]))}, balance-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6978, :column 8, :end-line 6978, :end-column 20, :private true, :arglists (quote ([key val ins right]))}, :private true, :name cljs.core/balance-left, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([key val ins right]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6978, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right]))}, rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2804, :column 12, :end-line 2804, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, :name cljs.core/rseq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag seq, :end-line 2804, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, ex-cause {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9763, :column 7, :end-line 9763, :end-column 15, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-cause, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9763, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, IReset {:meta {:file "cljs/core.cljs", :line 711, :column 14, :end-line 711, :end-column 20, :doc "Protocol for adding resetting functionality.", :protocol-symbol true, :protocol-info {:methods {-reset! [[o new-value]]}}}, :protocol-symbol true, :name cljs.core/IReset, :file "cljs/core.cljs", :end-column 20, :column nil, :line nil, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 711, :impls #{}, :doc "Protocol for adding resetting functionality."}, IEmptyableCollection {:meta {:file "cljs/core.cljs", :line 441, :column 14, :end-line 441, :end-column 34, :doc "Protocol for creating an empty collection.", :protocol-symbol true, :protocol-info {:methods {-empty [[coll]]}}}, :protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "cljs/core.cljs", :end-column 34, :column nil, :line nil, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 441, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for creating an empty collection."}, array-map-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5692, :column 8, :end-line 5692, :end-column 26, :private true, :arglists (quote ([m k]))}, :private true, :name cljs.core/array-map-index-of, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5692, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k]))}, ex-message {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9755, :column 7, :end-line 9755, :end-column 17, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, :name cljs.core/ex-message, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9755, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Alpha - subject to change.\n  Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, string-print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8600, :column 7, :end-line 8600, :end-column 19, :arglists (quote ([x]))}, :name cljs.core/string-print, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8600, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2343, :column 15, :end-line 2343, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/float, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2343, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, fixture2 {:name cljs.core/fixture2, :file "cljs/core.cljs", :line nil, :column nil, :end-line 9010, :end-column 14, :meta {:file "cljs/core.cljs", :line 9010, :column 6, :end-line 9010, :end-column 14}}, IRecord {:meta {:file "cljs/core.cljs", :line 587, :column 14, :end-line 587, :end-column 21, :doc "Marker interface indicating a record object", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IRecord, :file "cljs/core.cljs", :end-column 21, :column nil, :line nil, :protocol-info {:methods {}}, :info nil, :end-line 587, :impls #{}, :doc "Marker interface indicating a record object"}, pr-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8750, :column 7, :end-line 8750, :end-column 13, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr-str, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8750, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."}, first-array-for-longvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4637, :column 8, :end-line 4637, :end-column 31, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/first-array-for-longvec, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4637, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, es6-set-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5629, :column 7, :end-line 5629, :end-column 31, :arglists (quote ([coll]))}, :name cljs.core/es6-set-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5629, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, concat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3309, :column 7, :end-line 3309, :end-column 13, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/concat, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 3309, :max-fixed-arity 2, :fn-var true, :arglists ([] [x] [x y] [x y & zs]), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls."}, -methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9423, :column 4, :end-line 9423, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9423, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, js-reserved {:name cljs.core/js-reserved, :file "cljs/core.cljs", :line nil, :column nil, :end-line 9851, :end-column 17, :meta {:file "cljs/core.cljs", :line 9851, :column 6, :end-line 9851, :end-column 17}}, IDerefWithTimeout {:meta {:file "cljs/core.cljs", :line 538, :column 14, :end-line 538, :end-column 31, :doc nil, :protocol-symbol true, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}}, :protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "cljs/core.cljs", :end-column 31, :column nil, :line nil, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 538, :impls #{}, :doc nil}, symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 944, :column 7, :end-line 944, :end-column 13, :arglists (quote ([name] [ns name])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/symbol, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 944, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name])}, to-array-2d {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3194, :column 7, :end-line 3194, :end-column 18, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, :name cljs.core/to-array-2d, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3194, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 5013, :record false, :end-line 5013, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ExceptionInfo {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9711, :column 3, :end-line 9711, :end-column 16, :jsdoc ["@constructor"], :arglists (quote ([message data cause]))}, :name cljs.core/ExceptionInfo, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([message data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9711, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :jsdoc ["@constructor"]}, mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2467, :column 7, :end-line 2467, :end-column 10, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, :name cljs.core/mod, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2467, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, ISet {:meta {:file "cljs/core.cljs", :line 513, :column 14, :end-line 513, :end-column 18, :doc "Protocol for adding set functionality to a collection.", :protocol-symbol true, :protocol-info {:methods {-disjoin [[coll v]]}}}, :protocol-symbol true, :name cljs.core/ISet, :file "cljs/core.cljs", :end-column 18, :column nil, :line nil, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 513, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}, :doc "Protocol for adding set functionality to a collection."}, pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1837, :column 7, :end-line 1837, :end-column 10, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, :name cljs.core/pop, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1837, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, IPending {:meta {:file "cljs/core.cljs", :line 627, :column 14, :end-line 627, :end-column 22, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay.", :protocol-symbol true, :protocol-info {:methods {-realized? [[d]]}}}, :protocol-symbol true, :name cljs.core/IPending, :file "cljs/core.cljs", :end-column 22, :column nil, :line nil, :protocol-info {:methods {-realized? [[d]]}}, :info nil, :end-line 627, :impls #{cljs.core/Delay}, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay."}, -entry-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 607, :column 4, :end-line 607, :end-column 14, :protocol cljs.core/ISorted, :doc "Returns the key for entry.", :arglists (quote ([coll entry]))}, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll entry]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 607, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry])), :doc "Returns the key for entry."}, CHAR_MAP {:name cljs.core/CHAR_MAP, :file "cljs/core.cljs", :line nil, :column nil, :end-line 275, :end-column 11, :jsdoc ["@enum {string"], :meta {:file "cljs/core.cljs", :line 275, :column 3, :end-line 275, :end-column 11, :jsdoc ["@enum {string"]}}, pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4671, :column 8, :end-line 4671, :end-column 16, :private true, :arglists (quote ([pv level node]))}, :private true, :name cljs.core/pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4671, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node]))}, dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3384, :column 7, :end-line 3384, :end-column 14, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll key]), :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}}, :name cljs.core/dissoc!, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll key]), :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3384, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll key] [tcoll key & ks]), :doc "Returns a transient map that doesn't contain a mapping for key(s)."}, reductions {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8443, :column 7, :end-line 8443, :end-column 17, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/reductions, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8443, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f init coll]), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init."}, indexed? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1348, :column 16, :end-line 1348, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, :name cljs.core/indexed?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1348, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, - {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2243, :column 15, :end-line 2243, :end-column 16, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/-, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2243, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -equiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 568, :column 13, :end-line 568, :end-column 19, :tag boolean, :protocol cljs.core/IEquiv, :doc "Returns true if o and other are equal, false otherwise.", :arglists (quote ([o other]))}, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o other]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 568, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other])), :doc "Returns true if o and other are equal, false otherwise."}, ->RangeIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8259, :column 10, :end-line 8259, :end-column 23, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i end step]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([i end step]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 8259, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil}, ->ArrayNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6319, :column 10, :end-line 6319, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit cnt arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([edit cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6319, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag nil}, assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3372, :column 7, :end-line 3372, :end-column 13, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([tcoll key val]), :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc!, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([tcoll key val]), :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3372, :max-fixed-arity 3, :fn-var true, :arglists ([tcoll key val] [tcoll key val & kvs]), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll."}, hash-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8059, :column 7, :end-line 8059, :end-column 15, :arglists (quote ([] [& keys])), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keys]), :arglists-meta (nil nil)}}, :name cljs.core/hash-set, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keys]), :arglists-meta (nil nil)}, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8059, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keys]), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj."}, reduce-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2190, :column 7, :end-line 2190, :end-column 16, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, :name cljs.core/reduce-kv, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2190, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, reset! {:name cljs.core/reset!, :file "cljs/core.cljs", :line nil, :column nil, :end-line 6047, :end-column 55, :declared true, :meta {:file "cljs/core.cljs", :line 6047, :column 49, :end-line 6047, :end-column 55, :declared true}}, name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8127, :column 7, :end-line 8127, :end-column 11, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, :name cljs.core/name, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8127, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, ->RedNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7183, :column 10, :end-line 7183, :end-column 17, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val left right __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 7183, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, unchecked-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4645, :column 8, :end-line 4645, :end-column 27, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/unchecked-array-for, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4645, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, Fn {:meta {:file "cljs/core.cljs", :line 400, :column 14, :end-line 400, :end-column 16, :doc "Marker protocol", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/Fn, :file "cljs/core.cljs", :end-column 16, :column nil, :line nil, :protocol-info {:methods {}}, :info nil, :end-line 400, :impls #{cljs.core/Var function cljs.core/MetaFn}, :doc "Marker protocol"}, ffirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1511, :column 7, :end-line 1511, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, :name cljs.core/ffirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1511, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, sorted-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8065, :column 7, :end-line 8065, :end-column 17, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}, :method-params [(keys)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8065, :max-fixed-arity 0, :fn-var true, :arglists ([& keys]), :doc "Returns a new sorted set with supplied keys."}, pr-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8737, :column 8, :end-line 8737, :end-column 20, :private true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, :private true, :name cljs.core/pr-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8737, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7433, :record false, :end-line 7433, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->PersistentTreeMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7433, :column 10, :end-line 7433, :end-column 27, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([comp tree cnt meta __hash]))}, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 7433, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1311, :column 8, :end-line 1311, :end-column 20, :private true, :arglists (quote ([arr f] [arr f val] [arr f val idx])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([arr f] [arr f val] [arr f val idx]), :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/array-reduce, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([arr f] [arr f val] [arr f val idx]), :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}, :method-params ([arr f] [arr f val] [arr f val idx]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 1311, :max-fixed-arity 4, :fn-var true, :arglists ([arr f] [arr f val] [arr f val idx])}, counted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1344, :column 16, :end-line 1344, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, :name cljs.core/counted?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1344, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, tagged-literal {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9829, :column 7, :end-line 9829, :end-column 21, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, :name cljs.core/tagged-literal, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9829, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, println {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8780, :column 7, :end-line 8780, :end-column 14, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8780, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as print followed by (newline)"}, assoc-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4534, :column 7, :end-line 4534, :end-column 15, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, :name cljs.core/assoc-in, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([m p__7970 v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4534, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7811, :record false, :end-line 7811, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, bit-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2527, :column 16, :end-line 2527, :end-column 24, :tag boolean, :arglists (quote ([x n])), :doc "Test bit at index n"}, :name cljs.core/bit-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2527, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n"}, ->Namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9924, :column 10, :end-line 9924, :end-column 19, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}, :factory :positional, :arglists (quote ([obj name]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/->Namespace, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([obj name]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 9924, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj name])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, TransientHashMap {:meta {:file "cljs/core.cljs", :line 6657, :column 10, :end-line 6657, :end-column 26, :declared true}, :num-fields 5, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 6808, :record false, :declared true, :end-line 6808, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->PersistentHashMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6659, :column 10, :end-line 6659, :end-column 27, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta cnt root has-nil? nil-val __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6659, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5695, :column 8, :end-line 5695, :end-column 23, :private true, :arglists (quote ([arr k v]))}, :private true, :name cljs.core/array-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr k v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5695, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr k v]))}, ISwap {:meta {:file "cljs/core.cljs", :line 716, :column 14, :end-line 716, :end-column 19, :doc "Protocol for adding swapping functionality.", :protocol-symbol true, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}}, :protocol-symbol true, :name cljs.core/ISwap, :file "cljs/core.cljs", :end-column 19, :column nil, :line nil, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 716, :impls #{}, :doc "Protocol for adding swapping functionality."}, ChunkedCons {:meta {:file "cljs/core.cljs", :line 1911, :column 10, :end-line 1911, :end-column 21, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3096, :record false, :declared true, :end-line 3096, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, memoize {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9191, :column 7, :end-line 9191, :end-column 14, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, :name cljs.core/memoize, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9191, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, alter-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8946, :column 7, :end-line 8946, :end-column 18, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}}, :name cljs.core/alter-meta!, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}, :method-params [(iref f args)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8946, :max-fixed-arity 2, :fn-var true, :arglists ([iref f & args]), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects"}, ->StringBufferWriter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 734, :column 10, :end-line 734, :end-column 28, :protocols #{cljs.core/IWriter}, :skip-protocol-flag #{cljs.core/IWriter}, :factory :positional, :arglists (quote ([sb]))}, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([sb]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 734, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}}, zero? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2572, :column 16, :end-line 2572, :end-column 21, :tag boolean, :arglists (quote ([n])), :doc "Returns true if num is zero, else false"}, :name cljs.core/zero?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2572, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if num is zero, else false"}, tv-ensure-editable {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5141, :column 8, :end-line 5141, :end-column 26, :private true, :arglists (quote ([edit node]))}, :private true, :name cljs.core/tv-ensure-editable, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5141, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, *main-cli-fn* {:name cljs.core/*main-cli-fn*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 242, :end-column 16, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments", :meta {:file "cljs/core.cljs", :line 242, :column 3, :end-line 242, :end-column 16, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments"}}, -assoc-n {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 530, :column 9, :end-line 530, :end-column 17, :tag clj, :protocol cljs.core/IVector, :doc "Returns a new vector with value val added at position n.", :arglists (quote ([coll n val]))}, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 530, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val])), :doc "Returns a new vector with value val added at position n."}, unchecked-dec-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2371, :column 7, :end-line 2371, :end-column 24, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2371, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, hash-imap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2640, :column 8, :end-line 2640, :end-column 17, :private true, :arglists (quote ([m]))}, :private true, :name cljs.core/hash-imap, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2640, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, dominates {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9388, :column 8, :end-line 9388, :end-column 17, :private true, :arglists (quote ([x y prefer-table]))}, :private true, :name cljs.core/dominates, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9388, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3352, :column 7, :end-line 3352, :end-column 18, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, :name cljs.core/persistent!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3352, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, set-print-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 58, :column 7, :end-line 58, :end-column 20, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, :name cljs.core/set-print-fn!, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 58, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, nnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1526, :column 7, :end-line 1526, :end-column 12, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, :name cljs.core/nnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1526, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 6045, :record false, :end-line 6045, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7003, :column 8, :end-line 7003, :end-column 21, :private true, :arglists (quote ([key val left ins]))}, :private true, :name cljs.core/balance-right, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([key val left ins]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7003, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins]))}, throw-no-method-error {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9428, :column 8, :end-line 9428, :end-column 29, :private true, :arglists (quote ([name dispatch-val]))}, :private true, :name cljs.core/throw-no-method-error, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([name dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9428, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val]))}, demunge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9898, :column 8, :end-line 9898, :end-column 19, :private true, :arglists (quote ([munged-name]))}, :private true, :name cljs.core/demunge-str, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([munged-name]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9898, :max-fixed-arity 1, :fn-var true, :arglists (quote ([munged-name]))}, add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8960, :column 7, :end-line 8960, :end-column 16, :arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, :name cljs.core/add-watch, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([iref key f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8960, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, not-every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3735, :column 16, :end-line 3735, :end-column 26, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, :name cljs.core/not-every?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 3735, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, rem {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2478, :column 7, :end-line 2478, :end-column 10, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, :name cljs.core/rem, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2478, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, pr-sb-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8713, :column 8, :end-line 8713, :end-column 23, :private true, :arglists (quote ([objs opts]))}, :private true, :name cljs.core/pr-sb-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8713, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts]))}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/BitmapIndexedNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6108, :record false, :end-line 6108, :skip-protocol-flag nil}, ->NodeSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6541, :column 10, :end-line 6541, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta nodes i s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6541, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, some {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3740, :column 7, :end-line 3740, :end-column 11, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, :name cljs.core/some, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3740, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, INamed {:meta {:file "cljs/core.cljs", :line 701, :column 14, :end-line 701, :end-column 20, :doc "Protocol for adding a name.", :protocol-symbol true, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}}, :protocol-symbol true, :name cljs.core/INamed, :file "cljs/core.cljs", :end-column 20, :column nil, :line nil, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 701, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}, :doc "Protocol for adding a name."}, ->Box {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6045, :column 10, :end-line 6045, :end-column 13, :protocols #{}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([val]))}, :protocols #{}, :name cljs.core/->Box, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6045, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil}, IReduce {:meta {:file "cljs/core.cljs", :line 551, :column 14, :end-line 551, :end-column 21, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :protocol-symbol true, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}}, :protocol-symbol true, :name cljs.core/IReduce, :file "cljs/core.cljs", :end-column 21, :column nil, :line nil, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 551, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."}, drop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4239, :column 7, :end-line 4239, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4239, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided."}, js-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1918, :column 7, :end-line 1918, :end-column 13, :arglists (quote ([] [& keyvals])), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keyvals]), :arglists-meta (nil nil)}}, :name cljs.core/js-obj, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keyvals]), :arglists-meta (nil nil)}, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1918, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keyvals]), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values."}, ITransientCollection {:meta {:file "cljs/core.cljs", :line 648, :column 14, :end-line 648, :end-column 34, :doc "Protocol for adding basic functionality to transient collections.", :protocol-symbol true, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}}, :protocol-symbol true, :name cljs.core/ITransientCollection, :file "cljs/core.cljs", :end-column 34, :column nil, :line nil, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 648, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}, :doc "Protocol for adding basic functionality to transient collections."}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 3922, :record false, :end-line 3922, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1611, :column 7, :end-line 1611, :end-column 10, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :name cljs.core/nth, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1611, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences."}, sorted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1887, :column 16, :end-line 1887, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, :name cljs.core/sorted?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1887, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 177, :column 16, :end-line 177, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, :name cljs.core/nil?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 177, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, split-at {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4307, :column 7, :end-line 4307, :end-column 15, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, :name cljs.core/split-at, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4307, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, TransientHashSet {:meta {:file "cljs/core.cljs", :line 7809, :column 10, :end-line 7809, :end-column 26, :declared true}, :num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 7906, :record false, :declared true, :end-line 7906, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, *e {:name cljs.core/*e, :file "cljs/core.cljs", :line nil, :column nil, :end-line 161, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl", :meta {:file "cljs/core.cljs", :line 161, :column 3, :end-line 161, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl"}}, array-map-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5706, :column 8, :end-line 5706, :end-column 27, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/array-map-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5706, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, prn-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8728, :column 7, :end-line 8728, :end-column 24, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, :name cljs.core/prn-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8728, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, not-native {:name cljs.core/not-native, :file "cljs/core.cljs", :line nil, :column nil, :end-line 168, :end-column 16, :meta {:file "cljs/core.cljs", :line 168, :column 6, :end-line 168, :end-column 16}}, random-sample {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9080, :column 7, :end-line 9080, :end-column 20, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prob] [prob coll]), :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}}, :name cljs.core/random-sample, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prob] [prob coll]), :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}, :method-params ([prob] [prob coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9080, :max-fixed-arity 2, :fn-var true, :arglists ([prob] [prob coll]), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided."}, select-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7793, :column 7, :end-line 7793, :end-column 18, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, :name cljs.core/select-keys, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([map keyseq]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7793, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, bit-and {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2490, :column 7, :end-line 2490, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2490, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and"}, bounded-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3293, :column 8, :end-line 3293, :end-column 21, :private true, :arglists (quote ([s n]))}, :private true, :name cljs.core/bounded-count, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([s n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3293, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s n]))}, update {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4570, :column 7, :end-line 4570, :end-column 13, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column nil, :line nil, :end-line 4570, :max-fixed-arity 6, :fn-var true, :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value."}, gensym_counter {:name cljs.core/gensym_counter, :file "cljs/core.cljs", :line nil, :column nil, :end-line 8995, :end-column 20, :meta {:file "cljs/core.cljs", :line 8995, :column 6, :end-line 8995, :end-column 20}}, find-macros-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9990, :column 7, :end-line 9990, :end-column 21, :arglists (quote ([ns]))}, :name cljs.core/find-macros-ns, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9990, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns]))}, list* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3334, :column 7, :end-line 3334, :end-column 12, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([args] [a args] [a b args] [a b c args]), :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/list*, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([args] [a args] [a b args] [a b c args]), :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([args] [a args] [a b args] [a b c args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column nil, :line nil, :end-line 3334, :max-fixed-arity 4, :fn-var true, :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence."}, array-index-of-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5642, :column 8, :end-line 5642, :end-column 31, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5642, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->Keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2906, :column 10, :end-line 2906, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :factory :positional, :arglists (quote ([ns name fqn _hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ns name fqn _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 2906, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, update-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4543, :column 7, :end-line 4543, :end-column 16, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update-in, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column nil, :line nil, :end-line 4543, :max-fixed-arity 6, :fn-var true, :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created."}, prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9628, :column 7, :end-line 9628, :end-column 20, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, :name cljs.core/prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9628, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, hash-symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 891, :column 8, :end-line 891, :end-column 19, :private true, :arglists (quote ([sym]))}, :private true, :name cljs.core/hash-symbol, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 891, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, ensure-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1258, :column 7, :end-line 1258, :end-column 21, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, :name cljs.core/ensure-reduced, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1258, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, edit-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6079, :column 8, :end-line 6079, :end-column 20, :private true, :arglists (quote ([inode edit i a] [inode edit i a j b])), :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([inode edit i a] [inode edit i a j b]), :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/edit-and-set, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([inode edit i a] [inode edit i a j b]), :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}, :method-params ([inode edit i a] [inode edit i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6079, :max-fixed-arity 6, :fn-var true, :arglists ([inode edit i a] [inode edit i a j b])}, ->PersistentArrayMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5781, :column 10, :end-line 5781, :end-column 28, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta cnt arr __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5781, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, instance? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 880, :column 16, :end-line 880, :end-column 25, :tag boolean, :arglists (quote ([t o])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, :name cljs.core/instance?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([t o]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 880, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([t o])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, mix-collection-hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1157, :column 15, :end-line 1157, :end-column 34, :tag number, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/mix-collection-hash, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([hash-basis count]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 1157, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, re-find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8539, :column 7, :end-line 8539, :end-column 14, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, :name cljs.core/re-find, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8539, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, run! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9113, :column 7, :end-line 9113, :end-column 11, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, :name cljs.core/run!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([proc coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9113, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, char-escapes {:name cljs.core/char-escapes, :file "cljs/core.cljs", :line nil, :column nil, :end-line 8607, :end-column 28, :private true, :meta {:file "cljs/core.cljs", :line 8607, :column 16, :end-line 8607, :end-column 28, :private true}}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 1121, :record false, :end-line 1121, :skip-protocol-flag nil}, val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7764, :column 7, :end-line 7764, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, :name cljs.core/val, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7764, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, unchecked-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2352, :column 15, :end-line 2352, :end-column 28, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add, :variadic true, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2352, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, t7376 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t7376, :file "cljs/core.cljs", :type true, :anonymous true, :column nil, :line nil, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 194, :column 16, :end-line 194, :end-column 19, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, :name cljs.core/not, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 194, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, -vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 723, :column 4, :end-line 723, :end-column 12, :protocol cljs.core/IVolatile, :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 723, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}, fn->comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2083, :column 17, :end-line 2083, :end-column 31, :private true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, :private true, :name cljs.core/fn->comparator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2083, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1814, :column 7, :end-line 1814, :end-column 16, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, :name cljs.core/with-meta, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1814, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, unreduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1263, :column 7, :end-line 1263, :end-column 16, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, :name cljs.core/unreduced, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1263, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, record? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1902, :column 16, :end-line 1902, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, :name cljs.core/record?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1902, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, type {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 244, :column 7, :end-line 244, :end-column 11, :arglists (quote ([x])), :doc "Return x's constructor."}, :name cljs.core/type, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 244, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return x's constructor."}, identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 172, :column 16, :end-line 172, :end-column 26, :tag boolean, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, :name cljs.core/identical?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 172, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, -namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 705, :column 12, :end-line 705, :end-column 22, :tag string, :protocol cljs.core/INamed, :doc "Returns the namespace String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-namespace, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag string, :end-line 705, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of x."}, unchecked-divide-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2376, :column 15, :end-line 2376, :end-column 35, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-divide-int, :variadic true, :file "cljs/core.cljs", :end-column 35, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2376, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, ns-name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10006, :column 7, :end-line 10006, :end-column 14, :arglists (quote ([ns-obj]))}, :name cljs.core/ns-name, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 10006, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns-obj]))}, swap-global-hierarchy! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9262, :column 8, :end-line 9262, :end-column 30, :private true, :arglists (quote ([f & args])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :private true, :name cljs.core/swap-global-hierarchy!, :variadic true, :file "cljs/core.cljs", :end-column 30, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 9262, :max-fixed-arity 1, :fn-var true, :arglists ([f & args])}, max-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8148, :column 7, :end-line 8148, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params ([k x] [k x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 8148, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is greatest."}, ->PersistentTreeSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7943, :column 10, :end-line 7943, :end-column 27, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta tree-map __hash]))}, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta tree-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 7943, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, *out* {:name cljs.core/*out*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 36, :end-column 8, :dynamic true, :meta {:file "cljs/core.cljs", :line 36, :column 3, :end-line 36, :end-column 8, :dynamic true}}, ->ChunkBuffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3047, :column 10, :end-line 3047, :end-column 21, :protocols #{cljs.core/Object cljs.core/ICounted}, :skip-protocol-flag #{cljs.core/ICounted}, :factory :positional, :arglists (quote ([buf end]))}, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([buf end]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3047, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}}, hash-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 838, :column 7, :end-line 838, :end-column 18, :arglists (quote ([k]))}, :name cljs.core/hash-string, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 838, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7701, :record false, :end-line 7701, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9424, :column 4, :end-line 9424, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9424, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, set-validator! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4016, :column 7, :end-line 4016, :end-column 21, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, :name cljs.core/set-validator!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([iref val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4016, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, -meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 543, :column 16, :end-line 543, :end-column 21, :tag clj-or-nil, :protocol cljs.core/IMeta, :doc "Returns the metadata of object o.", :arglists (quote ([o]))}, :protocol cljs.core/IMeta, :name cljs.core/-meta, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj-or-nil, :end-line 543, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of object o."}, RedNode {:meta {:file "cljs/core.cljs", :line 6976, :column 10, :end-line 6976, :end-column 17, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7183, :record false, :declared true, :end-line 7183, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, -dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9426, :column 4, :end-line 9426, :end-column 16, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-dispatch-fn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9426, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, ->IndexedSeqIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1352, :column 10, :end-line 1352, :end-column 28, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 1352, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, -add-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9419, :column 4, :end-line 9419, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val method]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val method]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9419, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method])), :doc nil}, balance-left-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7025, :column 8, :end-line 7025, :end-column 24, :private true, :arglists (quote ([key val del right]))}, :private true, :name cljs.core/balance-left-del, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key val del right]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7025, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right]))}, swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3985, :column 7, :end-line 3985, :end-column 12, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([a f] [a f x] [a f x y]), :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/swap!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([a f] [a f x] [a f x y]), :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([a f] [a f x] [a f x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 3985, :max-fixed-arity 4, :fn-var true, :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in."}, vals {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7758, :column 7, :end-line 7758, :end-column 11, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, :name cljs.core/vals, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7758, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, -chunked-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 698, :column 4, :end-line 698, :end-column 17, :protocol cljs.core/IChunkedNext, :doc "Returns a new collection of coll without the first chunk.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 698, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first chunk."}, unchecked-subtract {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2414, :column 15, :end-line 2414, :end-column 33, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract, :variadic true, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2414, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, remove-pair {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6067, :column 8, :end-line 6067, :end-column 19, :private true, :arglists (quote ([arr i]))}, :private true, :name cljs.core/remove-pair, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6067, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i]))}, IMap {:meta {:file "cljs/core.cljs", :line 500, :column 14, :end-line 500, :end-column 18, :doc "Protocol for adding mapping functionality to collections.", :protocol-symbol true, :protocol-info {:methods {-dissoc [[coll k]]}}}, :protocol-symbol true, :name cljs.core/IMap, :file "cljs/core.cljs", :end-column 18, :column nil, :line nil, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 500, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}, :doc "Protocol for adding mapping functionality to collections."}, ->SeqIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3527, :column 10, :end-line 3527, :end-column 17, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([_seq _next]))}, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([_seq _next]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3527, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil}, sorted-set-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8070, :column 7, :end-line 8070, :end-column 20, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}, :method-params [(comparator keys)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8070, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keys]), :doc "Returns a new sorted set with supplied keys, using the supplied comparator."}, PersistentVector {:num-fields 6, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 4707, :record false, :end-line 4707, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1041, :column 7, :end-line 1041, :end-column 17, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, :name cljs.core/cloneable?, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1041, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, hash-string* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 821, :column 7, :end-line 821, :end-column 19, :arglists (quote ([s]))}, :name cljs.core/hash-string*, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 821, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, key-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6049, :column 16, :end-line 6049, :end-column 24, :tag boolean, :arglists (quote ([key other]))}, :name cljs.core/key-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key other]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 6049, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([key other]))}, ->LazyTransformer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3636, :column 10, :end-line 3636, :end-column 25, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([stepper first rest meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->LazyTransformer, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([stepper first rest meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3636, :max-fixed-arity 4, :fn-var true, :arglists (quote ([stepper first rest meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}}, -reset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9418, :column 4, :end-line 9418, :end-column 10, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9418, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, true? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1962, :column 16, :end-line 1962, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, :name cljs.core/true?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1962, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, find-ns-obj* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9946, :column 8, :end-line 9946, :end-column 20, :private true, :arglists (quote ([ctxt xs]))}, :private true, :name cljs.core/find-ns-obj*, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([ctxt xs]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9946, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ctxt xs]))}, array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 349, :column 14, :end-line 349, :end-column 19, :tag array, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, :name cljs.core/array, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([var-args]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag array, :end-line 349, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8771, :column 3, :end-line 8771, :end-column 8, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, :name cljs.core/print, :variadic true, :file "cljs/core.cljs", :end-column 8, :method-params ([objs]), :protocol-impl nil, :arglists-meta (), :column nil, :line nil, :end-line 8771, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, -peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 522, :column 4, :end-line 522, :end-column 9, :protocol cljs.core/IStack, :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-peek, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 522, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek."}, ISeq {:meta {:file "cljs/core.cljs", :line 467, :column 14, :end-line 467, :end-column 18, :doc "Protocol for collections to provide access to their items as sequences.", :protocol-symbol true, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}}, :protocol-symbol true, :name cljs.core/ISeq, :file "cljs/core.cljs", :end-column 18, :column nil, :line nil, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 467, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq}, :doc "Protocol for collections to provide access to their items as sequences."}, empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1558, :column 7, :end-line 1558, :end-column 12, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, :name cljs.core/empty, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1558, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9623, :column 7, :end-line 9623, :end-column 20, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, :name cljs.core/remove-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9623, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5329, :record false, :end-line 5329, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7044, :column 8, :end-line 7044, :end-column 25, :private true, :arglists (quote ([key val left del]))}, :private true, :name cljs.core/balance-right-del, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([key val left del]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7044, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del]))}, volatile! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4039, :column 7, :end-line 4039, :end-column 16, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, :name cljs.core/volatile!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4039, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, / {:protocol-inline nil, :meta {:tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :file "cljs/core.cljs"}, :name cljs.core//, :variadic true, :file "cljs/core.cljs", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, bitpos {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6076, :column 8, :end-line 6076, :end-column 14, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/bitpos, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6076, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, bit-or {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2496, :column 7, :end-line 2496, :end-column 13, :arglists (quote ([x y] [x y & more])), :doc "Bitwise or", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-or, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2496, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise or"}, m3-fmix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 782, :column 15, :end-line 782, :end-column 22, :tag number, :arglists (quote ([h1 len]))}, :name cljs.core/m3-fmix, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([h1 len]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 782, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len]))}, vector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4920, :column 7, :end-line 4920, :end-column 13, :arglists (quote ([& args])), :doc "Creates a new vector containing the args.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name cljs.core/vector, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 4920, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "Creates a new vector containing the args."}, hash-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2630, :column 8, :end-line 2630, :end-column 17, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/hash-coll, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2630, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, clone-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6058, :column 8, :end-line 6058, :end-column 21, :private true, :arglists (quote ([arr i a] [arr i a j b])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([arr i a] [arr i a j b]), :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/clone-and-set, :variadic false, :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([arr i a] [arr i a j b]), :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}, :method-params ([arr i a] [arr i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6058, :max-fixed-arity 5, :fn-var true, :arglists ([arr i a] [arr i a j b])}, array->transient-hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6036, :column 8, :end-line 6036, :end-column 33, :private true, :arglists (quote ([len arr]))}, :private true, :name cljs.core/array->transient-hash-map, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6036, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr]))}, >= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2302, :column 16, :end-line 2302, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>=, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2302, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false."}, ->TransientHashSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7906, :column 10, :end-line 7906, :end-column 26, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :factory :positional, :arglists (quote ([transient-map]))}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([transient-map]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 7906, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, drop-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4262, :column 7, :end-line 4262, :end-column 16, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [n s]), :arglists ([s] [n s]), :arglists-meta (nil nil)}}, :name cljs.core/drop-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [n s]), :arglists ([s] [n s]), :arglists-meta (nil nil)}, :method-params ([s] [n s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4262, :max-fixed-arity 2, :fn-var true, :arglists ([s] [n s]), :doc "Return a lazy sequence of all but the last n (default 1) items in coll"}, ->ArrayIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3512, :column 10, :end-line 3512, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3512, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, object? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 206, :column 16, :end-line 206, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, :name cljs.core/object?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 206, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, ->ArrayNodeSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6604, :column 10, :end-line 6604, :end-column 22, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta nodes i s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6604, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, tree-map-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7345, :column 8, :end-line 7345, :end-column 23, :private true, :arglists (quote ([left right]))}, :private true, :name cljs.core/tree-map-append, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([left right]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7345, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right]))}, not-empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3489, :column 7, :end-line 3489, :end-column 16, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, :name cljs.core/not-empty, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3489, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, distinct {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8094, :column 7, :end-line 8094, :end-column 15, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/distinct, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8094, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence of the elements of coll with duplicates removed"}, partition {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4491, :column 7, :end-line 4491, :end-column 16, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([n coll] [n step coll] [n step pad coll]), :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([n coll] [n step coll] [n step pad coll]), :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}, :method-params ([n coll] [n step coll] [n step pad coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 4491, :max-fixed-arity 4, :fn-var true, :arglists ([n coll] [n step coll] [n step pad coll]), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items."}, IMultiFn {:meta {:file "cljs/core.cljs", :line 9417, :column 14, :end-line 9417, :end-column 22, :doc nil, :protocol-symbol true, :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}}, :protocol-symbol true, :name cljs.core/IMultiFn, :file "cljs/core.cljs", :end-column 22, :column nil, :line nil, :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}, :info nil, :end-line 9417, :impls #{cljs.core/MultiFn}, :doc nil}, DEMUNGE_PATTERN {:name cljs.core/DEMUNGE_PATTERN, :file "cljs/core.cljs", :line nil, :column nil, :end-line 328, :end-column 21, :meta {:file "cljs/core.cljs", :line 328, :column 6, :end-line 328, :end-column 21}}, fix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2428, :column 16, :end-line 2428, :end-column 19, :tag number, :private true, :arglists (quote ([q]))}, :private true, :name cljs.core/fix, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2428, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q]))}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 2739, :record false, :end-line 2739, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IAssociative {:meta {:file "cljs/core.cljs", :line 491, :column 14, :end-line 491, :end-column 26, :doc "Protocol for adding associativity to collections.", :protocol-symbol true, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}}, :protocol-symbol true, :name cljs.core/IAssociative, :file "cljs/core.cljs", :end-column 26, :column nil, :line nil, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 491, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :doc "Protocol for adding associativity to collections."}, bit-flip {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2513, :column 7, :end-line 2513, :end-column 15, :arglists (quote ([x n])), :doc "Flip bit at index n"}, :name cljs.core/bit-flip, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2513, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n"}, long-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3227, :column 7, :end-line 3227, :end-column 17, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/long-array, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3227, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure."}, descendants {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9301, :column 7, :end-line 9301, :end-column 18, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/descendants, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9301, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships."}, imul {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 761, :column 17, :end-line 761, :end-column 21, :tag number, :arglists (quote ([a b]))}, :name cljs.core/imul, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 761, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b]))}, ->Delay {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9014, :column 10, :end-line 9014, :end-column 15, :protocols #{cljs.core/IPending cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}, :factory :positional, :arglists (quote ([f value]))}, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/->Delay, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f value]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 9014, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4656, :column 8, :end-line 4656, :end-column 17, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/array-for, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4656, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, merge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7769, :column 7, :end-line 7769, :end-column 12, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}}, :name cljs.core/merge, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}, :method-params [(maps)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 7769, :max-fixed-arity 0, :fn-var true, :arglists ([& maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result."}, ISeqable {:meta {:file "cljs/core.cljs", :line 576, :column 14, :end-line 576, :end-column 22, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :protocol-symbol true, :protocol-info {:methods {-seq [[o]]}}}, :protocol-symbol true, :name cljs.core/ISeqable, :file "cljs/core.cljs", :end-column 22, :column nil, :line nil, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 576, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to a type to be transformed into a sequence."}, js-mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2462, :column 7, :end-line 2462, :end-column 13, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, :name cljs.core/js-mod, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2462, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, integer? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1996, :column 16, :end-line 1996, :end-column 24, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is an integer."}, :name cljs.core/integer?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1996, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is an integer."}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 1761, :record false, :end-line 1761, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, NS_CACHE {:name cljs.core/NS_CACHE, :file "cljs/core.cljs", :line nil, :column nil, :end-line 9944, :end-column 14, :meta {:file "cljs/core.cljs", :line 9944, :column 6, :end-line 9944, :end-column 14}}, mapv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4466, :column 7, :end-line 4466, :end-column 11, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/mapv, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 4466, :max-fixed-arity 4, :fn-var true, :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments."}, partition-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8173, :column 7, :end-line 8173, :end-column 20, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([n] [n coll] [n step coll]), :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition-all, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([n] [n coll] [n step coll]), :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}, :method-params ([n] [n coll] [n step coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 8173, :max-fixed-arity 3, :fn-var true, :arglists ([n] [n coll] [n step coll]), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided."}, partition-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8393, :column 7, :end-line 8393, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/partition-by, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8393, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."}, ISequential {:meta {:file "cljs/core.cljs", :line 581, :column 14, :end-line 581, :end-column 25, :doc "Marker interface indicating a persistent collection of sequential items", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/ISequential, :file "cljs/core.cljs", :end-column 25, :column nil, :line nil, :protocol-info {:methods {}}, :info nil, :end-line 581, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Marker interface indicating a persistent collection of sequential items"}, ->LazySeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2979, :column 10, :end-line 2979, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta fn s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta fn s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 2979, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, equiv-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5436, :column 8, :end-line 5436, :end-column 17, :private true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false."}, :private true, :name cljs.core/equiv-map, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5436, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false."}, ->Volatile {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4031, :column 10, :end-line 4031, :end-column 18, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IDeref}, :factory :positional, :arglists (quote ([state]))}, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 4031, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}}, object-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3271, :column 7, :end-line 3271, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/object-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3271, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure."}, Keyword {:meta {:file "cljs/core.cljs", :line 170, :column 20, :end-line 170, :end-column 27, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 2906, :record false, :declared true, :end-line 2906, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, derive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9310, :column 7, :end-line 9310, :end-column 13, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/derive, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9310, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, seq-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3545, :column 7, :end-line 3545, :end-column 15, :arglists (quote ([coll]))}, :name cljs.core/seq-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3545, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IChunkedSeq {:meta {:file "cljs/core.cljs", :line 689, :column 14, :end-line 689, :end-column 25, :doc "Protocol for accessing a collection as sequential chunks.", :protocol-symbol true, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunkedSeq, :file "cljs/core.cljs", :end-column 25, :column nil, :line nil, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 689, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing a collection as sequential chunks."}, special-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9778, :column 16, :end-line 9778, :end-column 31, :tag boolean, :arglists (quote ([x]))}, :name cljs.core/special-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 9778, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, compare-keywords {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2894, :column 8, :end-line 2894, :end-column 24, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-keywords, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2894, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, ancestors {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9293, :column 7, :end-line 9293, :end-column 16, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/ancestors, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9293, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, subseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8229, :column 7, :end-line 8229, :end-column 13, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/subseq, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8229, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, LazyTransformer {:meta {:file "cljs/core.cljs", :line 3557, :column 10, :end-line 3557, :end-column 25, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/LazyTransformer, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 3636, :record false, :declared true, :end-line 3636, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/ISequential cljs.core/IWithMeta}}, gensym {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8997, :column 7, :end-line 8997, :end-column 13, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [prefix-string]), :arglists ([] [prefix-string]), :arglists-meta (nil nil)}}, :name cljs.core/gensym, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [prefix-string]), :arglists ([] [prefix-string]), :arglists-meta (nil nil)}, :method-params ([] [prefix-string]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8997, :max-fixed-arity 1, :fn-var true, :arglists ([] [prefix-string]), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'."}, -next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 479, :column 16, :end-line 479, :end-column 21, :tag clj-or-nil, :protocol cljs.core/INext, :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists (quote ([coll]))}, :protocol cljs.core/INext, :name cljs.core/-next, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj-or-nil, :end-line 479, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}, ->HashCollisionNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6425, :column 10, :end-line 6425, :end-column 27, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit collision-hash cnt arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->HashCollisionNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6425, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag nil}, delay? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9026, :column 16, :end-line 9026, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, :name cljs.core/delay?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 9026, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, create-inode-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6587, :column 8, :end-line 6587, :end-column 24, :private true, :arglists (quote ([nodes] [nodes i s])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([nodes] [nodes i s]), :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-inode-seq, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([nodes] [nodes i s]), :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}, :method-params ([nodes] [nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6587, :max-fixed-arity 3, :fn-var true, :arglists ([nodes] [nodes i s])}, flatten {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4444, :column 7, :end-line 4444, :end-column 14, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, :name cljs.core/flatten, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4444, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, -dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 503, :column 9, :end-line 503, :end-column 16, :tag clj, :protocol cljs.core/IMap, :doc "Returns a new collection of coll without the mapping for key k.", :arglists (quote ([coll k]))}, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 503, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k])), :doc "Returns a new collection of coll without the mapping for key k."}, doubles {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2459, :column 7, :end-line 2459, :end-column 14, :arglists (quote ([x]))}, :name cljs.core/doubles, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2459, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -contains-key? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 493, :column 13, :end-line 493, :end-column 27, :tag boolean, :protocol cljs.core/IAssociative, :doc "Returns true if k is a key in coll.", :arglists (quote ([coll k]))}, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 493, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k])), :doc "Returns true if k is a key in coll."}, remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8985, :column 7, :end-line 8985, :end-column 19, :arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference"}, :name cljs.core/remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([iref key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8985, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference"}, ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9739, :column 7, :end-line 9739, :end-column 14, :arglists (quote ([msg data] [msg data cause])), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([msg data] [msg data cause]), :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}}, :name cljs.core/ex-info, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([msg data] [msg data cause]), :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}, :method-params ([msg data] [msg data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9739, :max-fixed-arity 3, :fn-var true, :arglists ([msg data] [msg data cause]), :doc "Alpha - subject to change.\n  Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data."}, ifn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1991, :column 16, :end-line 1991, :end-column 20, :tag boolean, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, :name cljs.core/ifn?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1991, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, IAtom {:meta {:file "cljs/core.cljs", :line 708, :column 14, :end-line 708, :end-column 19, :doc "Marker protocol indicating an atom.", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IAtom, :file "cljs/core.cljs", :end-column 19, :column nil, :line nil, :protocol-info {:methods {}}, :info nil, :end-line 708, :impls #{cljs.core/Atom}, :doc "Marker protocol indicating an atom."}, ->PersistentQueue {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5369, :column 10, :end-line 5369, :end-column 25, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta count front rear __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([meta count front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5369, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, IWatchable {:meta {:file "cljs/core.cljs", :line 633, :column 14, :end-line 633, :end-column 24, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :protocol-symbol true, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}}, :protocol-symbol true, :name cljs.core/IWatchable, :file "cljs/core.cljs", :end-column 24, :column nil, :line nil, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 633, :impls #{cljs.core/Atom}, :doc "Protocol for types that can be watched. Currently only implemented by Atom."}, ->Stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3562, :column 10, :end-line 3562, :end-column 17, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([xform iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->Stepper, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3562, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :skip-protocol-flag nil}, pv-fresh-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4590, :column 8, :end-line 4590, :end-column 21, :private true, :arglists (quote ([edit]))}, :private true, :name cljs.core/pv-fresh-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([edit]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4590, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit]))}, subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5130, :column 7, :end-line 5130, :end-column 13, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v start] [v start end]), :arglists ([v start] [v start end]), :arglists-meta (nil nil)}}, :name cljs.core/subvec, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v start] [v start end]), :arglists ([v start] [v start end]), :arglists-meta (nil nil)}, :method-params ([v start] [v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5130, :max-fixed-arity 3, :fn-var true, :arglists ([v start] [v start end]), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done."}, -pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 670, :column 9, :end-line 670, :end-column 14, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with the last item removed from it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 670, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns tcoll with the last item removed from it."}, partial {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3807, :column 7, :end-line 3807, :end-column 14, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/partial, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column nil, :line nil, :end-line 3807, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args."}, chunked-seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1913, :column 16, :end-line 1913, :end-column 28, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq."}, :name cljs.core/chunked-seq?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1913, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq."}, replicate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4317, :column 7, :end-line 4317, :end-column 16, :arglists (quote ([n x])), :doc "Returns a lazy seq of n xs."}, :name cljs.core/replicate, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4317, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "Returns a lazy seq of n xs."}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5369, :record false, :end-line 5369, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8155, :column 7, :end-line 8155, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params ([k x] [k x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 8155, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is least."}, hash-iset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2650, :column 8, :end-line 2650, :end-column 17, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/hash-iset, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2650, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1248, :column 7, :end-line 1248, :end-column 14, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, :name cljs.core/reduced, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1248, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, re-matches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8527, :column 7, :end-line 8527, :end-column 17, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, :name cljs.core/re-matches, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8527, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, pr-writer-impl {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8631, :column 8, :end-line 8631, :end-column 22, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-impl, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8631, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, array-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7592, :column 7, :end-line 7592, :end-column 16, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/array-map, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 7592, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new array map with supplied mappings."}, ITransientSet {:meta {:file "cljs/core.cljs", :line 673, :column 14, :end-line 673, :end-column 27, :doc "Protocol for adding set functionality to a transient collection.", :protocol-symbol true, :protocol-info {:methods {-disjoin! [[tcoll v]]}}}, :protocol-symbol true, :name cljs.core/ITransientSet, :file "cljs/core.cljs", :end-column 27, :column nil, :line nil, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 673, :impls #{cljs.core/TransientHashSet}, :doc "Protocol for adding set functionality to a transient collection."}, ITER_SYMBOL {:name cljs.core/ITER_SYMBOL, :file "cljs/core.cljs", :line nil, :column nil, :end-line 272, :end-column 19, :meta {:file "cljs/core.cljs", :line 272, :column 8, :end-line 272, :end-column 19}}, unchecked-byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2346, :column 15, :end-line 2346, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-byte, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2346, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ArrayNode {:meta {:file "cljs/core.cljs", :line 6106, :column 10, :end-line 6106, :end-column 19, :declared true}, :num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 6319, :record false, :declared true, :end-line 6319, :skip-protocol-flag nil}, ->ChunkedSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4929, :column 10, :end-line 4929, :end-column 20, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([vec node i off meta __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 4929, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, every-pred {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4089, :column 7, :end-line 4089, :end-column 17, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/every-pred, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params ([p] [p1 p2] [p1 p2 p3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 4089, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates."}, keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7690, :column 7, :end-line 7690, :end-column 11, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, :name cljs.core/keys, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7690, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, missing-protocol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 250, :column 7, :end-line 250, :end-column 23, :arglists (quote ([proto obj]))}, :name cljs.core/missing-protocol, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([proto obj]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 250, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj]))}, load-file {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 265, :column 7, :end-line 265, :end-column 16, :arglists (quote ([file]))}, :name cljs.core/load-file, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([file]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 265, :max-fixed-arity 1, :fn-var true, :arglists (quote ([file]))}, PersistentArrayMap {:num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5781, :record false, :end-line 5781, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2023, :column 16, :end-line 2023, :end-column 25, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/distinct?, :variadic true, :file "cljs/core.cljs", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2023, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns true if no two of the arguments are ="}, never-equiv {:name cljs.core/never-equiv, :file "cljs/core.cljs", :line nil, :column nil, :end-line 5434, :end-column 27, :private true, :meta {:file "cljs/core.cljs", :line 5434, :column 16, :end-line 5434, :end-column 27, :private true}}, Stepper {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/Stepper, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3562, :record false, :end-line 3562, :skip-protocol-flag nil}, unchecked-short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2348, :column 15, :end-line 2348, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-short, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2348, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ->Range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8270, :column 10, :end-line 8270, :end-column 15, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta start end step __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([meta start end step __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 8270, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta start end step __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9634, :column 7, :end-line 9634, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, :name cljs.core/methods, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9634, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, odd? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3760, :column 16, :end-line 3760, :end-column 20, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, :name cljs.core/odd?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 3760, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, ->ArrayChunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3064, :column 10, :end-line 3064, :end-column 20, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr off end]))}, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 3064, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, lazy-transformer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3559, :column 7, :end-line 3559, :end-column 23, :arglists (quote ([stepper]))}, :name cljs.core/lazy-transformer, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([stepper]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3559, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stepper]))}, ci-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1278, :column 8, :end-line 1278, :end-column 17, :private true, :arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/ci-reduce, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists-meta (nil nil nil)}, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 1278, :max-fixed-arity 4, :fn-var true, :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization"}, *3 {:name cljs.core/*3, :file "cljs/core.cljs", :line nil, :column nil, :end-line 157, :end-column 5, :doc "bound in a repl thread to the third most recent value printed", :meta {:file "cljs/core.cljs", :line 157, :column 3, :end-line 157, :end-column 5, :doc "bound in a repl thread to the third most recent value printed"}}, -get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9422, :column 4, :end-line 9422, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9422, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->Var {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 959, :column 10, :end-line 959, :end-column 13, :protocols #{cljs.core/IEquiv cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([val sym _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :name cljs.core/->Var, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val sym _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 959, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}}, frequencies {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8434, :column 7, :end-line 8434, :end-column 18, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, :name cljs.core/frequencies, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8434, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, reduceable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1891, :column 16, :end-line 1891, :end-column 27, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, :name cljs.core/reduceable?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1891, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, string-hash-cache {:name cljs.core/string-hash-cache, :file "cljs/core.cljs", :line nil, :column nil, :end-line 817, :end-column 23, :meta {:file "cljs/core.cljs", :line 817, :column 6, :end-line 817, :end-column 23}}, rsubseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8244, :column 7, :end-line 8244, :end-column 14, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/rsubseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8244, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1238, :column 7, :end-line 1238, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, :name cljs.core/inc, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1238, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, type->str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 259, :column 7, :end-line 259, :end-column 16, :arglists (quote ([ty]))}, :name cljs.core/type->str, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ty]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 259, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty]))}, obj-clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5486, :column 8, :end-line 5486, :end-column 17, :private true, :arglists (quote ([obj ks]))}, :private true, :name cljs.core/obj-clone, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj ks]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5486, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks]))}, get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9638, :column 7, :end-line 9638, :end-column 17, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, :name cljs.core/get-method, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9638, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, vector-index-out-of-bounds {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4634, :column 8, :end-line 4634, :end-column 34, :private true, :arglists (quote ([i cnt]))}, :private true, :name cljs.core/vector-index-out-of-bounds, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4634, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt]))}, es6-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5616, :column 7, :end-line 5616, :end-column 27, :arglists (quote ([coll]))}, :name cljs.core/es6-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5616, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, bit-clear {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2508, :column 7, :end-line 2508, :end-column 16, :arglists (quote ([x n])), :doc "Clear bit at index n"}, :name cljs.core/bit-clear, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2508, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n"}, Range {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 8270, :record false, :end-line 8270, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4392, :column 7, :end-line 4392, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/filter, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4392, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->PersistentTreeMapSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6920, :column 10, :end-line 6920, :end-column 30, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta stack ascending? cnt __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6920, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, create-array-node-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6643, :column 8, :end-line 6643, :end-column 29, :private true, :arglists (quote ([nodes] [meta nodes i s])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([nodes] [meta nodes i s]), :arglists ([nodes] [meta nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-array-node-seq, :variadic false, :file "cljs/core.cljs", :end-column 29, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([nodes] [meta nodes i s]), :arglists ([nodes] [meta nodes i s]), :arglists-meta (nil nil)}, :method-params ([nodes] [meta nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6643, :max-fixed-arity 4, :fn-var true, :arglists ([nodes] [meta nodes i s])}, -assoc-n! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 668, :column 9, :end-line 668, :end-column 18, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with value val added at position n.", :arglists (quote ([tcoll n val]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 668, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val])), :doc "Returns tcoll with value val added at position n."}, IWithMeta {:meta {:file "cljs/core.cljs", :line 546, :column 14, :end-line 546, :end-column 23, :doc "Protocol for adding metadata to an object.", :protocol-symbol true, :protocol-info {:methods {-with-meta [[o meta]]}}}, :protocol-symbol true, :name cljs.core/IWithMeta, :file "cljs/core.cljs", :end-column 23, :column nil, :line nil, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 546, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/t7373 cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/t7376 cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding metadata to an object."}, list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2817, :column 7, :end-line 2817, :end-column 11, :arglists (quote ([& xs])), :doc "Creates a new list containing the items.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}}, :name cljs.core/list, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}, :method-params [(xs)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 2817, :max-fixed-arity 0, :fn-var true, :arglists ([& xs]), :doc "Creates a new list containing the items."}, + {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2235, :column 15, :end-line 2235, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/+, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2235, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 1352, :record false, :end-line 1352, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8388, :column 7, :end-line 8388, :end-column 17, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, :name cljs.core/split-with, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8388, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, ->VectorNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4588, :column 10, :end-line 4588, :end-column 20, :protocols #{}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit arr]))}, :protocols #{}, :name cljs.core/->VectorNode, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([edit arr]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 4588, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil}, aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 370, :column 7, :end-line 370, :end-column 11, :arglists (quote ([array i val] [array idx idx2 & idxv])), :doc "Sets the value at the index.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array i val]), :arglists ([array i val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :name cljs.core/aset, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array i val]), :arglists ([array i val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params ([array i val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 370, :max-fixed-arity 3, :fn-var true, :arglists ([array i val] [array idx idx2 & idxv]), :doc "Sets the value at the index."}, int-rotate-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 752, :column 15, :end-line 752, :end-column 30, :tag number, :arglists (quote ([x n]))}, :name cljs.core/int-rotate-left, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 752, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n]))}, keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2964, :column 7, :end-line 2964, :end-column 14, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/keyword, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2964, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name]), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically."}, ->Cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2834, :column 10, :end-line 2834, :end-column 14, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta first rest __hash]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 2834, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, *ns* {:name cljs.core/*ns*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 32, :end-column 7, :dynamic true, :doc "Var bound to the current namespace. Only used for bootstrapping.", :meta {:file "cljs/core.cljs", :line 32, :column 3, :end-line 32, :end-column 7, :dynamic true, :doc "Var bound to the current namespace. Only used for bootstrapping."}}, *assert* {:name cljs.core/*assert*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 40, :end-column 11, :dynamic true, :meta {:file "cljs/core.cljs", :line 40, :column 3, :end-line 40, :end-column 11, :dynamic true}}, create-tree-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6973, :column 8, :end-line 6973, :end-column 27, :private true, :arglists (quote ([tree ascending? cnt]))}, :private true, :name cljs.core/create-tree-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([tree ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 6973, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt]))}, ICollection {:meta {:file "cljs/core.cljs", :line 447, :column 14, :end-line 447, :end-column 25, :doc "Protocol for adding to a collection.", :protocol-symbol true, :protocol-info {:methods {-conj [[coll o]]}}}, :protocol-symbol true, :name cljs.core/ICollection, :file "cljs/core.cljs", :end-column 25, :column nil, :line nil, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 447, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding to a collection."}, multi-stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3616, :column 7, :end-line 3616, :end-column 20, :arglists (quote ([xform iters] [xform iters nexts])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([xform iters] [xform iters nexts]), :arglists ([xform iters] [xform iters nexts]), :arglists-meta (nil nil)}}, :name cljs.core/multi-stepper, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([xform iters] [xform iters nexts]), :arglists ([xform iters] [xform iters nexts]), :arglists-meta (nil nil)}, :method-params ([xform iters] [xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3616, :max-fixed-arity 3, :fn-var true, :arglists ([xform iters] [xform iters nexts])}, chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2455, :column 7, :end-line 2455, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/chars, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2455, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2593, :column 7, :end-line 2593, :end-column 10, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}}, :name cljs.core/str, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}, :method-params ([] [x]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 2593, :max-fixed-arity 1, :fn-var true, :arglists ([] [x] [x & ys]), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."}, next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1093, :column 12, :end-line 1093, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, :name cljs.core/next, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag seq, :end-line 1093, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, ASeq {:meta {:file "cljs/core.cljs", :line 464, :column 14, :end-line 464, :end-column 18, :doc "Marker protocol indicating an array sequence.", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/ASeq, :file "cljs/core.cljs", :end-column 18, :column nil, :line nil, :protocol-info {:methods {}}, :info nil, :end-line 464, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Marker protocol indicating an array sequence."}, pr-seq-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8707, :column 7, :end-line 8707, :end-column 20, :arglists (quote ([objs writer opts]))}, :name cljs.core/pr-seq-writer, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8707, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts]))}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3527, :record false, :end-line 3527, :skip-protocol-flag nil}, IFn {:meta {:file "cljs/core.cljs", :line 403, :column 14, :end-line 403, :end-column 17, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :protocol-symbol true, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}}, :protocol-symbol true, :name cljs.core/IFn, :file "cljs/core.cljs", :end-column 17, :column nil, :line nil, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 403, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/Subvec cljs.core/Var cljs.core/PersistentVector cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"}, regexp? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8522, :column 16, :end-line 8522, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, :name cljs.core/regexp?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 8522, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7583, :column 7, :end-line 7583, :end-column 15, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/hash-map, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 7583, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new hash map with supplied mappings."}, underive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9344, :column 7, :end-line 9344, :end-column 15, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/underive, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9344, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, array-copy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1938, :column 8, :end-line 1938, :end-column 18, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1938, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, obj-map-compare-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5464, :column 8, :end-line 5464, :end-column 28, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/obj-map-compare-keys, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5464, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -reset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 713, :column 4, :end-line 713, :end-column 11, :protocol cljs.core/IReset, :doc "Sets the value of o to new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IReset, :name cljs.core/-reset!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 713, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of o to new-value."}, -rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 471, :column 9, :end-line 471, :end-column 14, :tag clj, :protocol cljs.core/ISeq, :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-rest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 471, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}, nil-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3493, :column 7, :end-line 3493, :end-column 15, :arglists (quote ([]))}, :name cljs.core/nil-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3493, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8698, :column 8, :end-line 8698, :end-column 17, :private true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, :private true, :name cljs.core/pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8698, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, false? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1958, :column 16, :end-line 1958, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, :name cljs.core/false?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1958, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 4685, :record false, :end-line 4685, :skip-protocol-flag nil}, *print-readably* {:name cljs.core/*print-readably*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 86, :end-column 19, :dynamic true, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :meta {:file "cljs/core.cljs", :line 86, :column 3, :end-line 86, :end-column 19, :dynamic true, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}}, ints {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2457, :column 7, :end-line 2457, :end-column 11, :arglists (quote ([x]))}, :name cljs.core/ints, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2457, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, some-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4128, :column 7, :end-line 4128, :end-column 14, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/some-fn, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params ([p] [p1 p2] [p1 p2 p3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column nil, :line nil, :end-line 4128, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates."}, demunge-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9860, :column 8, :end-line 9860, :end-column 23, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/demunge-pattern, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9860, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *flush-on-newline* {:name cljs.core/*flush-on-newline*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 71, :end-column 21, :dynamic true, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :meta {:file "cljs/core.cljs", :line 71, :column 3, :end-line 71, :end-column 21, :dynamic true, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}}, to-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3184, :column 7, :end-line 3184, :end-column 15, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, :name cljs.core/to-array, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3184, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, build-subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5119, :column 8, :end-line 5119, :end-column 20, :private true, :arglists (quote ([meta v start end __hash]))}, :private true, :name cljs.core/build-subvec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5119, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash]))}, Namespace {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/Namespace, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 9924, :record false, :end-line 9924, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, list? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2732, :column 16, :end-line 2732, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, :name cljs.core/list?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2732, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, tree-map-remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7402, :column 8, :end-line 7402, :end-column 23, :private true, :arglists (quote ([comp tree k found]))}, :private true, :name cljs.core/tree-map-remove, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([comp tree k found]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 7402, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found]))}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/HashCollisionNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6425, :record false, :end-line 6425, :skip-protocol-flag nil}, array? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 182, :column 16, :end-line 182, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, :name cljs.core/array?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 182, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, prefers* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9370, :column 8, :end-line 9370, :end-column 16, :private true, :arglists (quote ([x y prefer-table]))}, :private true, :name cljs.core/prefers*, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9370, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1036, :column 7, :end-line 1036, :end-column 12, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, :name cljs.core/clone, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1036, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, scan-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5450, :column 8, :end-line 5450, :end-column 18, :private true, :arglists (quote ([incr k array]))}, :private true, :name cljs.core/scan-array, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([incr k array]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5450, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array]))}, demunge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9914, :column 7, :end-line 9914, :end-column 14, :arglists (quote ([name]))}, :name cljs.core/demunge, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9914, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, bit-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2518, :column 7, :end-line 2518, :end-column 14, :arglists (quote ([x])), :doc "Bitwise complement"}, :name cljs.core/bit-not, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2518, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement"}, quote-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8617, :column 17, :end-line 8617, :end-column 29, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/quote-string, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 8617, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2332, :column 15, :end-line 2332, :end-column 19, :tag number, :arglists (quote ([x]))}, :name cljs.core/byte, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2332, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, max {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2318, :column 15, :end-line 2318, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag number, :end-line 2318, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the greatest of the nums."}, IComparable {:meta {:file "cljs/core.cljs", :line 678, :column 14, :end-line 678, :end-column 25, :doc "Protocol for values that can be compared.", :protocol-symbol true, :protocol-info {:methods {-compare [[x y]]}}}, :protocol-symbol true, :name cljs.core/IComparable, :file "cljs/core.cljs", :end-column 25, :column nil, :line nil, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 678, :impls #{js/Date cljs.core/Keyword cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol cljs.core/UUID}, :doc "Protocol for values that can be compared."}, == {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2555, :column 16, :end-line 2555, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/==, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 2555, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined."}, parents {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9285, :column 7, :end-line 9285, :end-column 14, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/parents, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9285, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1570, :column 7, :end-line 1570, :end-column 12, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, :name cljs.core/count, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1570, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, -disjoin! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 675, :column 9, :end-line 675, :end-column 18, :tag clj, :protocol cljs.core/ITransientSet, :doc "Returns tcoll without v.", :arglists (quote ([tcoll v]))}, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 675, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v])), :doc "Returns tcoll without v."}, *loaded-libs* {:name cljs.core/*loaded-libs*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 124, :end-column 33, :dynamic true, :meta {:file "cljs/core.cljs", :line 124, :column 20, :end-line 124, :end-column 33, :dynamic true}}, ->TransientHashMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6808, :column 10, :end-line 6808, :end-column 26, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([edit root count has-nil? nil-val]))}, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 6808, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, array-index-of-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5652, :column 8, :end-line 5652, :end-column 30, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 5652, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ArrayChunk {:meta {:file "cljs/core.cljs", :line 3045, :column 10, :end-line 3045, :end-column 20, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3064, :record false, :declared true, :end-line 3064, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, sorted-map-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7623, :column 7, :end-line 7623, :end-column 20, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}, :method-params [(comparator keyvals)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 7623, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator."}, apply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3418, :column 7, :end-line 3418, :end-column 12, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/apply, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column nil, :line nil, :end-line 3418, :max-fixed-arity 5, :fn-var true, :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args."}, get-global-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9257, :column 8, :end-line 9257, :end-column 28, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/get-global-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9257, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, add-to-string-hash-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 832, :column 7, :end-line 832, :end-column 31, :arglists (quote ([k]))}, :name cljs.core/add-to-string-hash-cache, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 832, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9137, :column 7, :end-line 9137, :end-column 14, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."}, :name cljs.core/clj->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9137, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."}, TransientArrayMap {:meta {:file "cljs/core.cljs", :line 5709, :column 10, :end-line 5709, :end-column 27, :declared true}, :num-fields 3, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 5966, :record false, :declared true, :end-line 5966, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->TransientVector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5196, :column 10, :end-line 5196, :end-column 25, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([cnt shift root tail]))}, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([cnt shift root tail]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5196, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, t5671 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t5671, :file "cljs/core.cljs", :type true, :anonymous true, :column nil, :line nil, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, t7373 {:num-fields 2, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t7373, :file "cljs/core.cljs", :type true, :anonymous true, :column nil, :line nil, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, IChunkedNext {:meta {:file "cljs/core.cljs", :line 696, :column 14, :end-line 696, :end-column 26, :doc "Protocol for accessing the chunks of a collection.", :protocol-symbol true, :protocol-info {:methods {-chunked-next [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunkedNext, :file "cljs/core.cljs", :end-column 26, :column nil, :line nil, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 696, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing the chunks of a collection."}, interpose {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4347, :column 7, :end-line 4347, :end-column 16, :arglists (quote ([sep] [sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sep] [sep coll]), :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}}, :name cljs.core/interpose, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sep] [sep coll]), :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}, :method-params ([sep] [sep coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4347, :max-fixed-arity 2, :fn-var true, :arglists ([sep] [sep coll]), :doc "Returns a lazy seq of the elements of coll separated by sep"}, ->BlackNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7079, :column 10, :end-line 7079, :end-column 19, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val left right __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 7079, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, deref {:name cljs.core/deref, :file "cljs/core.cljs", :line nil, :column nil, :end-line 6047, :end-column 78, :declared true, :meta {:file "cljs/core.cljs", :line 6047, :column 73, :end-line 6047, :end-column 78, :declared true}}, pv-aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4593, :column 8, :end-line 4593, :end-column 15, :private true, :arglists (quote ([node idx]))}, :private true, :name cljs.core/pv-aget, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4593, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx]))}, assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1727, :column 7, :end-line 1727, :end-column 12, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll k v]), :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll k v]), :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1727, :max-fixed-arity 3, :fn-var true, :arglists ([coll k v] [coll k v & kvs]), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index."}, transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3347, :column 7, :end-line 3347, :end-column 16, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, :name cljs.core/transient, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3347, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, -disjoin {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 515, :column 9, :end-line 515, :end-column 17, :tag clj, :protocol cljs.core/ISet, :doc "Returns a new collection of coll that does not contain v.", :arglists (quote ([coll v]))}, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 515, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v])), :doc "Returns a new collection of coll that does not contain v."}, chunk-cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3160, :column 7, :end-line 3160, :end-column 17, :arglists (quote ([chunk rest]))}, :name cljs.core/chunk-cons, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([chunk rest]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3160, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest]))}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3512, :record false, :end-line 3512, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9772, :column 7, :end-line 9772, :end-column 17, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, :name cljs.core/comparator, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9772, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, sorted-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7614, :column 7, :end-line 7614, :end-column 17, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 7614, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings."}, drop-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4276, :column 7, :end-line 4276, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4276, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided."}, IWriter {:meta {:file "cljs/core.cljs", :line 612, :column 14, :end-line 612, :end-column 21, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :protocol-symbol true, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}}, :protocol-symbol true, :name cljs.core/IWriter, :file "cljs/core.cljs", :end-column 21, :column nil, :line nil, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 612, :impls #{cljs.core/StringBufferWriter}, :doc "Protocol for writing. Currently only implemented by StringBufferWriter."}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 7633, :record false, :end-line 7633, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9037, :column 16, :end-line 9037, :end-column 25, :tag boolean, :arglists (quote ([d])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, :name cljs.core/realized?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([d]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 9037, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([d])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, *print-fn* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 46, :column 3, :end-line 46, :end-column 13, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-fn*, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column nil, :dynamic true, :line nil, :end-line 46, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2041, :column 15, :end-line 2041, :end-column 22, :tag number, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, :name cljs.core/compare, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2041, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, complement {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3764, :column 16, :end-line 3764, :end-column 26, :tag boolean, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, :name cljs.core/complement, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 3764, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, lookup-sentinel {:name cljs.core/lookup-sentinel, :file "cljs/core.cljs", :line nil, :column nil, :end-line 1956, :end-column 31, :private true, :meta {:file "cljs/core.cljs", :line 1956, :column 16, :end-line 1956, :end-column 31, :private true}}, -assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 657, :column 9, :end-line 657, :end-column 16, :tag clj, :protocol cljs.core/ITransientAssociative, :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists (quote ([tcoll key val]))}, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 657, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val])), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}, *print-dup* {:name cljs.core/*print-dup*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 102, :end-column 14, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :meta {:file "cljs/core.cljs", :line 102, :column 3, :end-line 102, :end-column 14, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}}, string-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3509, :column 7, :end-line 3509, :end-column 18, :arglists (quote ([x]))}, :name cljs.core/string-iter, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3509, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9122, :column 4, :end-line 9122, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9122, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}, IDeref {:meta {:file "cljs/core.cljs", :line 533, :column 14, :end-line 533, :end-column 20, :doc "Protocol for adding dereference functionality to a reference.", :protocol-symbol true, :protocol-info {:methods {-deref [[o]]}}}, :protocol-symbol true, :name cljs.core/IDeref, :file "cljs/core.cljs", :end-column 20, :column nil, :line nil, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 533, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}, :doc "Protocol for adding dereference functionality to a reference."}, sequence {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3708, :column 7, :end-line 3708, :end-column 15, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [xform coll]), :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}}, :name cljs.core/sequence, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [xform coll]), :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}, :method-params ([coll] [xform coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 3708, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [xform coll] [xform coll & colls]), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"}, constantly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3774, :column 7, :end-line 3774, :end-column 17, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, :name cljs.core/constantly, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3774, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, ->RangedIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4685, :column 10, :end-line 4685, :end-column 24, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i base arr v start end]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([i base arr v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 4685, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil}, chunked-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5005, :column 7, :end-line 5005, :end-column 18, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}}, :name cljs.core/chunked-seq, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :protocol-impl nil, :arglists-meta (nil nil nil), :column nil, :line nil, :end-line 5005, :max-fixed-arity 5, :fn-var true, :arglists ([vec i off] [vec node i off] [vec node i off meta])}, ISorted {:meta {:file "cljs/core.cljs", :line 595, :column 14, :end-line 595, :end-column 21, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :protocol-symbol true, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}}, :protocol-symbol true, :name cljs.core/ISorted, :file "cljs/core.cljs", :end-column 21, :column nil, :line nil, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 595, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. "}, make-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 332, :column 14, :end-line 332, :end-column 24, :tag array, :arglists (quote ([size] [type size])), :doc "Construct a JavaScript array of specified size. Accepts ignored type\n  argument for compatibility with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size] [type size]), :arglists ([size] [type size]), :arglists-meta (nil nil)}}, :name cljs.core/make-array, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size] [type size]), :arglists ([size] [type size]), :arglists-meta (nil nil)}, :method-params ([size] [type size]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag array, :end-line 332, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([size] [type size]), :doc "Construct a JavaScript array of specified size. Accepts ignored type\n  argument for compatibility with Clojure."}, shorts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2456, :column 7, :end-line 2456, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/shorts, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2456, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, *unchecked-if* {:name cljs.core/*unchecked-if*, :file "cljs/core.cljs", :line nil, :column nil, :end-line 18, :end-column 20, :meta {:file "cljs/core.cljs", :line 18, :column 6, :end-line 18, :end-column 20}}, ->RSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1451, :column 10, :end-line 1451, :end-column 14, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([ci i meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ci i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 1451, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, enable-console-print! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 135, :column 7, :end-line 135, :end-column 28, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, :name cljs.core/enable-console-print!, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 135, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, -flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 616, :column 4, :end-line 616, :end-column 10, :protocol cljs.core/IWriter, :doc "Flush writer.", :arglists (quote ([writer]))}, :protocol cljs.core/IWriter, :name cljs.core/-flush, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 616, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer])), :doc "Flush writer."}, completing {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2206, :column 7, :end-line 2206, :end-column 17, :arglists (quote ([f] [f cf])), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f cf]), :arglists ([f] [f cf]), :arglists-meta (nil nil)}}, :name cljs.core/completing, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f cf]), :arglists ([f] [f cf]), :arglists-meta (nil nil)}, :method-params ([f] [f cf]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2206, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f cf]), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument."}, unchecked-negate-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2406, :column 7, :end-line 2406, :end-column 27, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate-int, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2406, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->PersistentVector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4707, :column 10, :end-line 4707, :end-column 26, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta cnt shift root tail __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 4707, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, equiv-sequential {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2615, :column 8, :end-line 2615, :end-column 24, :private true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, :private true, :name cljs.core/equiv-sequential, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2615, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, hash-unordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1183, :column 15, :end-line 1183, :end-column 34, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-unordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 1183, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, repeat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4312, :column 7, :end-line 4312, :end-column 13, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([x] [n x]), :arglists ([x] [n x]), :arglists-meta (nil nil)}}, :name cljs.core/repeat, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([x] [n x]), :arglists ([x] [n x]), :arglists-meta (nil nil)}, :method-params ([x] [n x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4312, :max-fixed-arity 2, :fn-var true, :arglists ([x] [n x]), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs."}, unchecked-inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2383, :column 7, :end-line 2383, :end-column 20, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2383, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, nthnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2583, :column 7, :end-line 2583, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, :name cljs.core/nthnext, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2583, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, preserving-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9042, :column 8, :end-line 9042, :end-column 26, :private true, :arglists (quote ([rf]))}, :private true, :name cljs.core/preserving-reduced, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 9042, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf]))}, get-validator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4026, :column 7, :end-line 4026, :end-column 20, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, :name cljs.core/get-validator, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([iref]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4026, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3500, :record false, :end-line 3500, :skip-protocol-flag nil}, number? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 189, :column 16, :end-line 189, :end-column 23, :tag boolean, :arglists (quote ([n])), :doc "Returns true if x is a JavaScript number."}, :name cljs.core/number?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 189, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if x is a JavaScript number."}, -conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 650, :column 9, :end-line 650, :end-column 15, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Adds value val to tcoll and returns tcoll.", :arglists (quote ([tcoll val]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 650, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val])), :doc "Adds value val to tcoll and returns tcoll."}, ->PersistentArrayMapSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5711, :column 10, :end-line 5711, :end-column 31, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr i _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5711, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, chunk-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3177, :column 7, :end-line 3177, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3177, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 8162, :record false, :end-line 8162, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8775, :column 7, :end-line 8775, :end-column 16, :arglists (quote ([& objs])), :doc "print to a string, returning it", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/print-str, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column nil, :line nil, :end-line 8775, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "print to a string, returning it"}, not-any? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3749, :column 16, :end-line 3749, :end-column 24, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, :name cljs.core/not-any?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 3749, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, into-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 384, :column 14, :end-line 384, :end-column 24, :tag array, :arglists (quote ([aseq] [type aseq])), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([aseq] [type aseq]), :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}}, :name cljs.core/into-array, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([aseq] [type aseq]), :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}, :method-params ([aseq] [type aseq]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag array, :end-line 384, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([aseq] [type aseq]), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure."}, -hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 573, :column 4, :end-line 573, :end-column 9, :protocol cljs.core/IHash, :doc "Returns the hash code of o.", :arglists (quote ([o]))}, :protocol cljs.core/IHash, :name cljs.core/-hash, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 573, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of o."}, -dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 663, :column 9, :end-line 663, :end-column 17, :tag clj, :protocol cljs.core/ITransientMap, :doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists (quote ([tcoll key]))}, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj, :end-line 663, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key])), :doc "Returns a new transient collection of tcoll without the mapping for key."}, ->Reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1244, :column 10, :end-line 1244, :end-column 17, :protocols #{cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IDeref}, :factory :positional, :arglists (quote ([val]))}, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 1244, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}}, chunk-buffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3061, :column 7, :end-line 3061, :end-column 19, :arglists (quote ([capacity]))}, :name cljs.core/chunk-buffer, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 3061, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity]))}, seqable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1978, :column 16, :end-line 1978, :end-column 24, :tag boolean, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable"}, :name cljs.core/seqable?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1978, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable"}, symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 886, :column 16, :end-line 886, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, :name cljs.core/symbol?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 886, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, m3-hash-unencoded-chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 798, :column 15, :end-line 798, :end-column 38, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-unencoded-chars, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 798, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, unchecked-char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2347, :column 15, :end-line 2347, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-char, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag number, :end-line 2347, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5427, :record false, :end-line 5427, :skip-protocol-flag #{cljs.core/IEquiv}}, -invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 407, :column 4, :end-line 407, :end-column 11, :protocol cljs.core/IFn, :doc nil, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :top-fn {:variadic false, :max-fixed-arity 22, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}}, :protocol cljs.core/IFn, :name cljs.core/-invoke, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 22, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil), :column nil, :line nil, :end-line 407, :max-fixed-arity 22, :fn-var true, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :doc nil}, coll? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1865, :column 16, :end-line 1865, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, :name cljs.core/coll?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag boolean, :end-line 1865, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, get-in {:protocol-inline nil, :meta {:added "1.2", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m ks] [m ks not-found]), :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :column 7, :line 4513, :end-line 4513, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, :added "1.2", :name cljs.core/get-in, :variadic false, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m ks] [m ks not-found]), :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :method-params ([m ks] [m ks not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 4513, :max-fixed-arity 3, :fn-var true, :arglists ([m ks] [m ks not-found]), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, fnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1521, :column 7, :end-line 1521, :end-column 12, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/fnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 1521, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, IList {:meta {:file "cljs/core.cljs", :line 584, :column 14, :end-line 584, :end-column 19, :doc "Marker interface indicating a persistent list", :protocol-symbol true, :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IList, :file "cljs/core.cljs", :end-column 19, :column nil, :line nil, :protocol-info {:methods {}}, :info nil, :end-line 584, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}, :doc "Marker interface indicating a persistent list"}, List {:meta {:file "cljs/core.cljs", :line 1342, :column 30, :end-line 1342, :end-column 34, :declared true}, :num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 2673, :record false, :declared true, :end-line 2673, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 510, :column 4, :end-line 510, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the value of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 510, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the value of the map entry."}, bytes {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2454, :column 7, :end-line 2454, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/bytes, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 2454, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ObjMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5496, :column 10, :end-line 5496, :end-column 16, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta keys strobj update-count __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :factory :positional, :line nil, :end-line 5496, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, compare-symbols {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 896, :column 8, :end-line 896, :end-column 23, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-symbols, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 896, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 578, :column 16, :end-line 578, :end-column 20, :tag clj-or-nil, :protocol cljs.core/ISeqable, :doc "Returns a seq of o, or nil if o is empty.", :arglists (quote ([o]))}, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :ret-tag clj-or-nil, :end-line 578, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns a seq of o, or nil if o is empty."}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:meta :dup :else :cljs.core/none :validator :default :ns :fallback-impl :flush-on-newline :no-test :descendants :ancestors :readably :more-marker :print-length :ok :parents :tag :mutable :arglists :alt-impl :keywordize-keys :cljs.core/not-found}, :order [:flush-on-newline :readably :meta :dup :print-length :else :default :mutable :arglists :validator :tag :cljs.core/not-found :cljs.core/none :more-marker :alt-impl :fallback-impl :keywordize-keys :parents :descendants :ancestors :ok :no-test :ns]}, :doc nil}
